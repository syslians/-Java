# 스택 개념

스택(Stack) 어원은 ‘쌓는다’이다. 스택은 어원에서 짐작할 수 있듯이 먼저 입력한 데이터를 제일 나중에 꺼낼 수 있는 자료구조이다. 스택은 우리 주변에서도 쉽게 찾아볼 수 있다.

먼저 들어간 것이 마지막에 나오는 규칙을 선입후출 또는 FILO(First In Last Out)라고 한다. 이때, 스택에 삽입하는 연산을 push, 꺼내는 연산을 pop이라고 한다.

# 스택의 정의

ADT는 우리말로 추상 자료형(Abstract datat type)인데, 인터페이스만 있고 실제로 구현되지 않은 자료형이다.

## 스택의 ADT

스택에는 push, pop, isFull, isEmpty와 같은 연산을 정의해야 하며, 최근에 삽입한 데이터의 위치를 저장할 변수인 top도 있어야 한다.

## 스택 세부 동작에 대해 조금 더 자세히 알아보기

스택에 데이터를 추가하는 경우를 생각해보자. 내부적으로 `isFull()`을 수행해 data 배열에 데이터가 가득 찼는지 확인하고, 그렇지 않으면 top을 1만큼 증가시킨 후 top이 가리키는 위치 data[0]에 3을 추가한다.

반대로 pop 연산을 수행할 경우, 내부적으로 `isEmpty()` 함수를 우선 수행해 data 배열에 데이터가 없는 건 아닌지 확인하고, 데이터가 있다면 top을 1만큼 감소시키고, 데이터 3을 반환한다.

## Stack 클래스 사용하기

데이터를 그냥 저장하고 순서와 상관 없이 임의 접근하기만 해도 되면 배열을 사용하면 되지만, 최근에 삽입한 데이터를 대상으로 뭔가 연산해야 한다면 스택을 떠올리는 것이 좋다.

자바의 Stack 클래스는 크기를 동적으로 관리하므로, `max_size`나 `isFull()` 메서드는 없다. 다만, `size()`를 제공해 스택에 들어 있는 데이터의 수를 알 수 있다. 또한, 스택에서 가장 최근에 push한 데이터를 꺼내지 않으면서 반환만 하는 `peek()` 메서드도 제공한다.

# 몸풀기 문제

## 문제 08 - 올바른 괄호

### **문제 설명**

괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어

- "()()" 또는 "(())()" 는 올바른 괄호입니다.
- ")()(" 또는 "(()(" 는 올바르지 않은 괄호입니다.

'(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.

### 제한사항

- 문자열 s의 길이 : 100,000 이하의 자연수
- 문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.

### 입출력 예

| s | answer |
| --- | --- |
| "()()" | true |
| "(())()" | true |
| ")()(" | false |
| "(()(" | false |

### 풀이

```java
import java.util.Stack;

class Solution {
    boolean solution(String s) {
        boolean isSuccess = true;
        Stack<Character> stack = new Stack<>();
        
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            
            if (c == '(') {
                stack.push(c);
            } else if (stack.isEmpty()) {
                isSuccess = false;
                break;
            } else if (stack.peek() != '(') {
                isSuccess = false;
                break;
            } else {
                stack.pop();
            }
        }
        
        if (!stack.isEmpty()) {
            isSuccess = false;
        }
        
        return isSuccess;
    }
}
```

### 문제 분석하고 풀기

문제에서 주목할 내용은 닫힌 괄호가 임의 위치의 열린 괄호와 상쇄되는 것이 아니라 **닫힌 괄호가 나오기 전의, 즉 가장 가까운 (최근) 열린 괄호와 상쇄된다는 것이다. 가장 가까운 (최근)이라는 키워드를 보고 스택을 떠올리는 감각이 있어야 한다.**

1. 문자열을 앞에서 하나씩 보며 열린 괄호가 나오면 푸시
2. 닫힌 괄호가 나오면 팝 연산을 통해 문자열에서 열린 괄호, 닫힌 괄호 한 쌍을 상쇄
3. 1~2를 마지막 문자열까지 반복해 스택에 열린 괄호가 남아 있다면 짝이 맞지 않는 것이고, 괄호가 남아있지 않다면 짝이 맞은 것으로 판단한다.

### 시간 복잡도 분석하기

N은 s의 길이다. s를 순회하며 괄호의 쌍을 확인하므로 시간 복잡도는 `O(N)`이다. 참고로 괄호 쌍을 확인할 때 `push()` 메서드와 `pop()` 메서드의 시간 복잡도는 `O(1)`이다.

## 문제 09 - 10진수를 2진수로 변환하기

10진수를 입력받아 2진수로 변환해 반환하는 `solution()` 함수를 구현하세요.

### 제약 조건

- decimal은 1이상 10억 미만의 자연수

### 입출력의 예

| decimal | 반환값 |
| --- | --- |
| 10 | 1010 |
| 27 | 11011 |
| 12345 | 11000000111001 |

### 풀이

```java
import java.util.*;
import java.lang.*;
import java.io.*;

// The main method must be in a class named "Main".
class Main {
    public static void main(String[] args) {
        toBinary(10);
        toBinary(27);
        toBinary(12345);
    }

    private static void toBinary(int n) {
        Stack<Integer> s = new Stack<>();

        while (n > 0) {
            s.push(n % 2);
            n = n / 2;
        }

        print(s);
    }

    private static void print(Stack<Integer> s) {
	    // 10억 미만의 자연수를 필요로하므로 문자열로 변환하는 과정이 필요하다.
        while (!s.isEmpty()) {
            System.out.print(s.pop());
        }
        System.out.println();
    }
}
```

### 문제 분석하고 풀기

10진수를 2진수로 표현하는 과정은 다음과 같으며, 이 과정은 이미 수학적으로 증명된 것이므로 별도로 설명하지 않는다.

1. 10진수 N을 2로 나눈 나머지, 즉, %2 연산을 한 값을 저장하고, N은 2로 나눈다.
2. 몫이 0이 아니라면 나머지를 버리고 다시 1을 수행한다.
3. 모든 과정이 끝나고 1에서 저장한 수를 뒤부터 순서대로 가져와 붙인다.

**십진수를 2진수로 변환하는 과정**

십진수 13을 이진수로 변환하는 과정은 13을 2로 나누면서 나눈 나머지를 순서대로 저장한다. 그리고 이 과정을 0이 될 때까지 반복한다. 몫이 0이 되면 저장한 값을 뒤부터 순서대로 읽으면 1101로 이진수 변환이 완료된다.

이 문제도 스택으로 쉽게 풀 수 있다. 스택에 저장할 데이터가 무엇인지 정의하면 된다. 나머지를 거꾸로 읽으면 우리가 원하는 이진수가 된다. 즉, 나머지를 스택에 쌓고, 하나씩 꺼내면 답이 나온다.

### 시간 복잡도 분석하기

`N`은 이진수로 변환할 숫자이다. `N`을 이진수로 변환하는 과정은 N이 1이 될 때까지 2로 계속 나누므로 연산 횟수는 `O(logN)`이다. String의 `+` 연산자는 수행할 때마다 객체를 새로 생성한다. 따라서 문자열의 길이가 계속 길어지는 반복문 내에서는 가급적 String의 `+` 연산보다는 `StringBuilder`를 사용하는 것이 바람직하다.

`StringBuilder`를 사용한 코드의 시간 복잡도는 `O(logN)`이다. 만약 String `+` 연산을 사용한다면 `O((logN)^2)`이 된다.
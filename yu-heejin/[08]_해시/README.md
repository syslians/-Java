# 해시의 개념

## 해시 자세히 알아보기

해시는 해시 함수를 사용해서 변환한 값을 인덱스로 삼아 키와 값을 저장해서 빠른 데이터 탐색을 제공하는 자료구조이다. 보통은 인덱스를 활용해서 탐색을 빠르게 만들지만, 해시는 키를 활용해 데이터 탐색을 빠르게 한다.

해시는 키와 데이터를 일대일 대응해 저장하므로 키를 통해 데이터에 바로 접근할 수 있다. 사람에게는 숫자(인덱스)로 데이터를 관리하는 배열보다 조금 더 접근성이 좋은 자료구조라 할 수 있다.

해시 함수는 키를 일정한 해시값으로 변환시켜 값을 찾을 수 있게 한다.

### 해시의 특징

첫 번째, 해시는 단방향으로 동작한다. 즉, 키를 통해 값을 찾을 수 있지만 값을 통해 키를 찾을 수는 없다.

두 번째, 찾고자 하는 값을 `O(1)`에서 바로 찾을 수 있다. 키 자체가 해시 함수에 의해 값이 있는 인덱스가 되므로 값을 찾기 위한 탐색 과정이 필요없다.

세 번째, 값을 인덱스로 활용하려면 적절한 변환 과정을 거쳐야 한다.

단방향으로만 동작하는 해시의 특성은 외부에 정보를 안전하게 제공한다는 특징이 있어 네트워크 보안에서 많이 활용된다.

### 해시를 사용하지 않는다면 어떻게 될까?

만약 해시를 사용하지 않는다면 우리는 값의 위치에 대한 어떤 정보도 알 수 없다. 그래서 어떤 데이터를 찾으려면 전체 데이터를 확인해보는 방법밖에는 없다. 이 경우 탐색 효율이 떨어진다.

반면, 해시를 사용하면 순차 탐색할 필요 없이 해시 함수를 활용해 특정 값이 있는 위치를 바로 찾을 수 있어 탐색 효율이 좋다. **해시 테이블은 키와 대응한 값이 저장되어 있는 공간이고, 해시 테이블의 각 데이터를 버킷(bucket)이라고 부른다.**

## 해시의 특성을 활용하는 분야

해시는 단방향으로만 검색할 수 있는 대신 빠르게 원하는 값을 검색할 수 있다. 코딩 테스트에서는 특정 데이터를 탐색하는 횟수가 많을 경우 해시를 고려하면 좋다. 다음은 해시가 활용되는 실제 사례이다.

- 비밀번호 관리: 사용자의 비밀번호를 그대로 노출해 저장하는 것은 위험하므로 해시 함수를 활용해 해싱한 비밀번호를 저장한다. 비밀번호가 맞는지 확인할 때도 마찬가지이다. 사용자가 입력한 비밀번호를 해싱해 확인한다.
- 데이터베이스 인덱싱: 데이터베이스에 저장된 데이터를 효율적으로 검색할 때 해시를 활용한다.
- 블록체인: 블록체인에서 해시 함수는 핵심 역할을 한다. 각 블록은 이전 블록의 해시값을 포함하고 있으며, 이를 통해 데이터 무결성을 확인할 수 있다.

# 해시 함수

자바에서는 해시셋 혹은 해시맵이라는 표준 API를 제공하는데 이 클래스는 해시와 거의 동일하게 동작하므로 해시를 쉽게 사용할 수 있다.

## 해시 함수를 구현할 때 고려할 내용

첫 번째, 해시 함수가 변환한 값은 인덱스로 활용해야 하므로 해시 테이블의 크기를 넘으면 안된다. 만약 해시 테이블의 크기가 N이라면, 인덱스 값은 0 ~ N-1이다.

두 번째, 해시 함수가 변환한 값의 충돌은 최대한 적게 발생해야 한다. 충돌의 의미는 서로 다른 두 키에 대해 해싱 함수를 적용한 결과가 동일한 것을 의미한다.

## 자주 사용하는 해시 함수 알아보기

### 나눗셈법

**나눗셈법(division method)은 키를 소수로 나눈 나머지를 활용한다.** 이처럼 나머지를 취하는 연산을 모듈러 연산이라고 하며, 연산자는 `%`로 표시한다. 예를 들어 `7%2 = 1`이다.

나눗셈법을 수식으로 작성하면 다음과 같다.

$$
h(x) = x      mod    k
$$

`x`는 키, `k`는 소수이다. 키를 소수로 나눈 나머지를 인덱스로 사용한다.

***나눗셈법에 소수가 아닌 15를 사용하면 어떻게 될까?***

**소수를 사용하는 이유는 다른 수를 사용할 때보다 충돌이 적기 때문이다.** 예를 들어, 소수가 아닌 15를 나눗셈법에 적용했다고 가정하자. 나눗셈법에 적용했다는 의미는 위 식에서 `k`에 15를 적용한다는 의미이다. 이때, `x`가 3의 배수인 경우를 살펴보면 규칙적으로 계속 같은 해시값이 반복되는 것을 확인할 수 있다.

x가 3의 배수, k가 15인 경우 해시값이 3, 6, 9, 12, 0이 반복되며 충돌이 많이 발생한다. `x`가 `k`의 약수 중 하나인 3의 배수이기 때문이다.

***왜 충돌이 많이 발생할까?***

N의 약수 중 하나를 M이라고 한다면, 임의의 수 `k`에 대해 `m * k = N`이 되는 수가 반드시 존재한다. `N`이 `15`이고 `m`이 3인 경우, `3 * 5 = 15`이므로 k = 5가 된다. 그리고 `k`를 주기로 같은 해시값이 반복된다. 따라서, `k`는 1과 자기 자신 빼고는 약수가 없는 수, 즉, 소수를 사용하는 것이 좋다.

```bash
# 소수를 사용하지 않은 경우
x = 3   → 3  % 15 = 3  
x = 6   → 6  % 15 = 6  
x = 9   → 9  % 15 = 9  
x = 12  → 12 % 15 = 12  
x = 15  → 15 % 15 = 0  
x = 18  → 18 % 15 = 3  
x = 21  → 21 % 15 = 6  
x = 24  → 24 % 15 = 9  

# 소수를 사용한 경우
x = 3   → 3  % 13 = 3  
x = 6   → 6  % 13 = 6  
x = 9   → 9  % 13 = 9  
x = 12  → 12 % 13 = 12  
x = 15  → 15 % 13 = 2  
x = 18  → 18 % 13 = 5  
x = 21  → 21 % 13 = 8  
x = 24  → 24 % 13 = 11  
x = 27  → 27 % 13 = 1  
x = 30  → 30 % 13 = 4  
```

***나눗셈법의 해시 테이블 크기는 K***

나눗셈법은 해시 테이블의 크기가 자연스럽게 `K`가 된다. 왜냐하면 `K`에 대해 모듈러 연산을 했을 때 나올 수 있는 값은 `0 ~ K - 1`이기 때문이다. **즉, 상황에 따라 아주 많은 데이터를 저장해야 한다면 굉장히 큰 소수가 필요할 수도 있다.**

### 곱셈법

곱셈법(multiplication method)은 나눗셈법과 비슷하게 모듈러 연산을 활용하지만 소수는 활용하지 않는다. 곱셈법의 공식은 다음과 같다.

$$
h(x) = (((x * A) mod 1) * m)
$$

`m`은 최대 버킷의 개수, A는 황금비(golden ration number)이다. 황금비는 무한 소수로 대략 1.6180339887…이다. 황금비는 수학적으로 임의의 길이를 두 부분으로 나누었을 때, 전체와 긴 부분의 비율이 긴 부분과 짧은 부분의 비율과 같은 비율을 뜻한다.

1. 키에 황금비를 곱한다.
2. 1단계에서 구한 값의 모듈러 1을 취한다. 쉽게 말해 정수 부분을 버리고 소수 부분만 취한다. [`0.xxx`](http://0.xxx) 형태의 값이 나온다.
3. 2단계에서 구한 값을 가지고 실제 해시 테이블에 매핑한다. **테이블의 크기가 `m`이면 2단계에서 구한 수에 `m`을 곱한 후 정수 부분을 취하는 연산을 통해 해시 테이블에 매핑할 수 있다.** 2단계에서 구했던 값은 `0.xxx`의 값이므로 매핑할 테이블의 크기인 `m`을 곱하면 테이블의 인덱스인 `0 ~ (m-1)`에 매치할 수 있다.

곱셈법은 황금비를 사용하므로 나눗셈법처럼 소수가 필요 없다는 장점이 있다. 따라서 해시 테이블의 크기가 커져도 추가 작업이 필요 없다.

### 문자열 해싱

지금까지 알아본 해시 함수는 키의 자료형이 숫자였다. 이번에는 **키의 자료형이 문자열일 때도 사용할 수 있는 해시 함수인 문자열 해싱 기법이 있다.**

**문자열 해싱은 문자열의 문자를 숫자로 변환하고 이 숫자들을 다항식의 값으로 변환해 해싱한다.**

$$
hash(s) = (s[0] + s[1] * p + s[2] * p^2 .... s[n - 1] * p^n-1) mod m
$$

`p`는 31이고, `m`은 해시 테이블의 최대 크기이다. `p`를 31로 정한 이유는 **홀수이면서 메르센 소수이기 때문이다.** 메르센 소수는 일반적으로 `2^N-1` 형식으로 표시할 수 있는 숫자 중 소수인 수를 말한다. 메르센 소수는 해시에서 충돌을 줄이는데 효과적이라는 연구 결과가 있다.

기존에는 키 자체가 숫자였으므로 바로 해시 함수를 적용했지만, 키가 문자열이면 각 문자열의 문자들을 적절한 숫자로 변경한 다음 해시 함수를 적용해야 한다. 이러한 변환 과정을 통해 문자열이 키인 데이터에도 해시를 사용할 수 있다.
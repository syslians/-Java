# 투 포인터(Two Pointer)

리스트에 순차적으로 접근해야 할 때 **두 개의 점 의 위치를 기록하면서 처리하는 알고리즘**

**배열이나 리스트에서 ‘두 개의 포인터’를 사용해 ‘특정 조건을 만족하는 부분 구간’을 효율적으로 탐색하는 알고리즘**

- **일반적으로, 배열이나 리스트가 ‘정렬되어 있을 때’ 사용한다.**
- 팰린드롬 검사나 정렬되지 않은 배열에서 슬라이딩 윈도우를 사용하는 경우에는 정렬하지 않는다.

왼쪽 포인터와 오른쪽 포인터를 사용하며, 이들은 각각 탐색 범위의 시작과 끝을 가리킨다.

일반적으로 **탐색 범위 내에서 특정 조건을 만족하는 요소**를 찾거나, **조건을 만족하는 부분 배열의 길이** 등을 계산하는데 사용할 수 있다.

# 수행 순서

1. 배열 또는 리스트의 시작 위치에 첫 번째 포인터와 두 번째 포인터를 설정한다.
    - 종류에 따라 포인터의 초기 값이 다르다.
2. 두 포인터 사이의 구간을 조사하고 조건을 확인한다.
3. 조건을 만족할 경우 알고리즘을 종료하고, 만족하지 않을 경우 첫번째 또는 두 번째 포인터를 이동시킨다.

# 투 포인터 특징

## 장점

### 시간 복잡도 감소

- 완전 탐색보다 훨씬 빠른 `O(N)`으로 문제를 해결할 수 있다.

### 메모리 효율성

- 별도의 추가 메모리 없이 인덱스만을 이용해 해결 가능하다.

### 다양한 문제 해결 가능

- 정렬된 배열을 기반으로 한 문제에서 매우 유용하다.

## 단점

### 정렬이 필수적

- 대부분의 경우 정렬된 배열에서만 사용 가능하므로, 정렬이 필요할 경우 `O(NlogN)`의 추가 비용이 발생한다.

### 적용 범위 제한

- 투 포인터를 사용할 수 있는 문제 유형이 제한적이며, 모든 문제에 적용할 수 없다.

### 포인터 이동 방식이 문제마다 다름

- 문제마다 포인터를 어떻게 이동해야 하는지에 대한 분석이 필요하다.

## 주의할 점

### 배열이 정렬되지 않은 경우 사용할 수 없다.

- 대부분의 투포인터 문제는 정렬된 배열에서만 유효하다.

### 무한 루프 방지

- 반복문 종료 조건을 명확하게 설정해야 한다.

### 경우에 따라 포인터 이동 방향을 다르게 지정해야 한다.

- left를 증가시킬지, right를 감소시킬 지 등의 적절한 로직을 설정해야 한다.

# 시간 복잡도

투 포인터를 사용하면 한번의 순회만으로 결과를 찾을 수 있기 때문에 완전 탐색보다 효율적이다.

- 완전 탐색: `O(N^2)`
- 투 포인터 알고리즘: `O(N)`

# 투 포인터 알고리즘의 종류

## 고정 길이 슬라이딩 윈도우

고정된 길이의 윈도우를 사용해 배열이나 리스트를 탐색한다.

윈도우의 크기를 일정하게 유지하면서 왼쪽 포인터와 오른쪽 포인터를 이동시키며 필요한 계산을 수행한다.

**부분 배열의 합이나 평균을 계산하는 등의 문제**에 사용될 수 있다.

## 가변 길이 슬라이딩 윈도우

가변 길이의 윈도우를 사용해 배열이나 리스트를 탐색한다.

윈도우의 크기를 필요에 따라 변경하면서 왼쪽 포인터 혹은 오른쪽 포인터를 이동시키며 필요한 계산을 수행한다.

**최소 길이 부분 배열이나 최대 길이 부분 배열**을 찾는 등의 문제에 사용될 수 있다.

## 두 포인터의 합과 차

배열이나 리스트에서 **두 개의 포인터를 사용해 합이나 차를 계산하는 문제를 해결한다.**

- 배열의 범위가 아니라 두 개의 숫자의 합/차를 계산한다.

보통 왼쪽 포인터와 오른쪽 포인터를 사용하며, 이들은 각각 탐색 범위의 시작과 끝을 가리킨다.

**두 요소의 합이나 차가 주어진 값과 일치하는지 확인**하는 등의 문제에 사용된다.

# 투 포인터 응용 예시

## 정렬된 배열에서 특정 합을 찾는 문제

- 두 개의 수를 더해서 특정 값을 만들어야 하는 문제에서 활용된다.

## 구간 합(부분 배열 합) 문제

- 특정 조건을 만족하는 연속된 부분 배열을 찾는데 사용된다.

## 문자열 또는 배열 내 특정 패턴 찾기

- 팰린드롬 검사와 같은 문제에서 유용하다.

## 교차 검증 및 병합 문제

- 두 개의 정렬된 리스트를 하나의 정렬된 리스트로 병합하는 과정에서도 사용된다.

# 예제로 보는 투 포인터

## 백준 - 두 수의 합

[](https://www.acmicpc.net/problem/3273)

### 정답 코드

```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());
        int[] numbers = new int[n];

        String[] input = br.readLine().split(" ");

        for (int i = 0; i < n; i++) {
            numbers[i] = Integer.parseInt(input[i]);
        }

        // 투 포인터를 사용하기 위한 정렬
        Arrays.sort(numbers);

        int x = Integer.parseInt(br.readLine());

        int left = 0;
        int right = n - 1;
        int answer = 0;

        // <= 는 안됨, 두 수여야함
        while (left < right) {
            int first = numbers[left];
            int second = numbers[right];

            if (first + second == x) {
                answer++;
                left++;   // right++ 도 가능
            } else if (first + second > x) {
                // 크면 오른쪽 값을 줄인다.
                right--;
            } else if (first + second < x) {
                // 작으면 왼쪽 값을 늘린다.
                left++;
            }
        }

        System.out.println(answer);
    }
}
```

## 백준 - List of Unique Numbers

[](https://www.acmicpc.net/problem/13144)

# 추가 자료

[yu-heejin/이것이_취업을_위한_코딩테스트다_정리/기타-알고리즘 at main · coding-test-study-with-java/yu-heejin](https://github.com/coding-test-study-with-java/yu-heejin/tree/main/%EC%9D%B4%EA%B2%83%EC%9D%B4_%EC%B7%A8%EC%97%85%EC%9D%84_%EC%9C%84%ED%95%9C_%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4_%EC%A0%95%EB%A6%AC/%EA%B8%B0%ED%83%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-two-pointer)

# 참고 자료

- https://adjh54.tistory.com/384
- https://best-coding.tistory.com/87
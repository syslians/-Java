후위표기식

| 시간 제한 | 메모리 제한 | 제출   | 정답   | 맞힌 사람 | 정답 비율  |
|----------|-------------|--------|--------|-----------|------------|
| 2 초     | 128 MB      | 57719  | 22658  | 17359     | 38.713%    |

수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 a+b는 전위 표기법으로는 +ab이고, 후위 표기법으로는 ab+가 된다.

이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 a+b*c를 후위 표기식으로 바꾸면 abc*+가 된다.

중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 (a+bc*)가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.

다른 예를 들어 그림으로 표현하면 A+B*C-D/E를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.
![image](https://github.com/user-attachments/assets/c3f210f9-040d-49aa-8eab-ae6d803800bb)

이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오

입력
첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 -A+B와 같이 -가 가장 앞에 오거나 AB와 같이 *가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 +, -, *, /, (, )로만 이루어져 있으며, 길이는 100을 넘지 않는다. 

출력
첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오

-----------------------------------------------------------------------------------------------
Java 코드 전체 예제

    import java.util.Stack;

    public class Main {
        public static void main(String[] args) {
            // 명령행 인자로 중위 표기식을 받음
            if (args.length == 0) {
                System.out.println("사용법: java Main \"중위표기식\"");
                return;
            }
            String expression = args[0];  // ex: A*(B+C)
            String postfix = infixToPostfix(expression);
            System.out.println(postfix);
        }

        public static String infixToPostfix(String expr) {
            StringBuilder result = new StringBuilder();
            Stack<Character> stack = new Stack<>();
    
            for (char c : expr.toCharArray()) {
                if (Character.isLetter(c)) {
                    // 피연산자는 결과에 바로 추가
                    result.append(c);
                } else if (c == '(') {
                    // 여는 괄호는 스택에 push
                    stack.push(c);
                } else if (c == ')') {
                    // 닫는 괄호가 나오면 '(' 나올 때까지 pop해서 결과에 추가
                    while (!stack.isEmpty() && stack.peek() != '(') {
                        result.append(stack.pop());
                    }
                    stack.pop(); // '(' 제거
                } else {
                    // 연산자는 스택 위에 있는 연산자와 우선순위 비교 후 처리
                    while (!stack.isEmpty() && precedence(stack.peek()) >= precedence(c)) {
                        if (stack.peek() == '(') break;
                        result.append(stack.pop());
                    }
                    stack.push(c);
                }
            }
    
            // 스택에 남은 연산자를 모두 결과에 추가
            while (!stack.isEmpty()) {
                result.append(stack.pop());
            }
    
            return result.toString();
        }
    
        // 연산자 우선순위 함수
        public static int precedence(char op) {
            switch (op) {
                case '+': case '-':
                    return 1;
                case '*': case '/':
                    return 2;
                default:
                    return 0;
            }
        }
    }

## 코드 실행 흐름 상세 설명
| 단계 | 수행 내용               | 상세                                                                                                                                                             |
| -- | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1  | `main` 진입           | 명령행 인자 `args[0]`로 수식 문자열 받음                                                                                                                                    |
| 2  | `infixToPostfix` 호출 | 입력 수식을 후위 표기식으로 변환하는 함수 실행                                                                                                                                     |
| 3  | 수식 문자 순회            | `for`문으로 입력 문자열 문자 하나씩 검사                                                                                                                                      |
| 4  | 문자 처리               | - **알파벳(피연산자)**: 결과에 바로 추가<br>- **`(`**: 스택에 push<br>- **`)`**: `(` 나올 때까지 스택에서 pop하여 결과 추가 후 `(` 버림<br>- **연산자(`+ - * /`)**: 스택 top과 우선순위 비교 후 적절히 pop하고 push |
| 5  | 반복 종료 후             | 스택에 남은 연산자 모두 pop해서 결과에 추가                                                                                                                                     |
| 6  | 결과 리턴               | 후위 표기식 문자열 반환                                                                                                                                                  |
| 7  | 결과 출력               | `main`에서 변환된 문자열 출력                                                                                                          
|

## 알고리즘 단계별 요약
1. 문자열을 왼쪽부터 한글자씩 읽음
2. 문자가 피연산자라면 -> 결과 문자열에 바로 추가
3. 문자가 여는 괄호 ( 라면 -> 스택에 Push
4. 문자가 닫는 괄호라면 )
   - ( 가 나올때까지 스택에서 pop 하여 결과에 추가
   - ( 는 pop만 하고 결과에 추가하지 않음
5. 문자가 연산자 (+, -, *, /) 라면:
   - 스택 상단의 연산자와 우선순위 비교
   - 같거나 높은 우선순위를 가진 연산자는 모두 pop하여 출력
   - 그 후 자신을 스택에 Push
6. 모든 문자 처리 후, 스택에 남은 연산자를 모두 결과에 추가

## 연산자 우선순위
| 연산자      | 우선순위    |
| -------- | ------- |
| `*`, `/` | 2 (높음)  |
| `+`, `-` | 1       |
| 나머지      | 0 (기본값) |

## 시간/공간 복잡도
| 항목     | 복잡도    | 설명                          |
| ------ | ------ | --------------------------- |
| 시간 복잡도 | `O(n)` | 수식 한 번 순회, 스택 연산도 평균 O(1)   |
| 공간 복잡도 | `O(n)` | 결과 문자열 + 스택 최대 길이 = 수식 길이 n |

## 요약 키포인트
- 스택은 연산자의 임시 저장소 역할

- 괄호는 연산 순서를 강제하는 도구

- 후위 표기식은 연산자 우선순위를 따로 고려하지 않아도 됨

- 코드의 핵심은 "우선순위 비교"와 "괄호 처리"

## 예시 동작 
| 문자  | 스택 상태     | 결과(후위식) |
| --- | --------- | ------- |
| `A` | `[]`      | `A`     |
| `*` | `[*]`     | `A`     |
| `(` | `[* (]`   | `A`     |
| `B` | `[* (]`   | `AB`    |
| `+` | `[* ( +]` | `AB`    |
| `C` | `[* ( +]` | `ABC`   |
| `)` | `[*]`     | `ABC+`  |
| 종료  | `[]`      | `ABC+*` |

## 풀이 정리
이 문젠는 중위표기식을 후위 표기식으로 변환하는 스택 문제입니다. 중위 표기식은 사람이 읽기에는 직관적이지만, 계산 순서를 명확히 알기 위해서는 괄호와 연산자 우선순위를 따로 처리해야 합니다. 반면, 후위 표기식은 괄호 없이도 계산 순서가 내포되어 있어, 컴퓨터나 스택 기반 계산기에서는 훨씬 효율적으로 사용됩니다. 컴파일러의 파서 일부 기능과 유사한 구조를 가지고 있습니다.

풀이 방식은 다음과 같습니다.
1. 입력 문자열은 왼쪽부터 한 문자씩 순회합니다.
2. 피연산자(알파벳)는 바로 출력합니다.
3. 연산자는 스택에 저장하되, 이미 있는 연산자와 우선순위를 비교하여, 필요시 스택에서 pop한 뒤 출력합니다.
4. 괄호는 예외처리 합니다. 여는 괄호는 스택에 그대로 저장하고, 닫는 괄호는 여는 괄호가 나올 때까지 연산자를 pop하여 출력합니다.
5. 모든 문자를 처리한 후에는, 스택에 남아 있는 연산자를 전부 출력합니다.

우선순위는 *와 /가 가장 높고, +와 -는 그보다 낮습니다. 괄호는 연산 우선순위를 강제하기 위해 사용되며, 후위 표기식에서는 실제로 출력되지 않습니다.

이 알고리즘의 시간 복잡도는 O(n)이며, n은 입력 수식의 길이입니다. 스택을 이용한 연산이 평균적으로 O(1)이기 때문에 전체 처리는 매우 효율적으로 이루어집니다.





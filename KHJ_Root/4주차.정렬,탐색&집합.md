# 정렬과 탐색

## 정렬 알고리즘의 종류
<img width="1005" height="632" alt="image" src="https://github.com/user-attachments/assets/e8886bc6-0c26-4510-9779-2b60d01b749f" />

### 널리 사용되는 정렬 알고리즘
자주 사용되는 정렬 알고리즘을 알아 두면 문제풀이 능력을 크게 향상시킬 수 있습니다. 아래 정리한 알고리즘 가운데에서는 병합 정렬(merge sort), 
퀵 정렬(quick sort), 버킷 정렬(bucket sort)와 관련된 문제가 가장 많이 출제 되는것으로 보입니다. 

| 알고리즘 종류 | 설명 |
|--------|--------|
| 퀵 정렬 (Quick Sort) | 분할 정복 방식을 이용하여 배열을 빠르게 정렬하는 알고리즘입니다. |
| Arrays.sort()| 퀵 정렬을 사용하여 배열을 정렬하는데 사용되며 기본 타입 배열과 객체 타입 배열 모두에 대해 사용할 수 있습니다. |
| Collections.sort() | 퀵 정렬을 사용하여 객체를 정렬하는데 사용되며 List, Set, Queue 등의 컬렉션 프레임워크에 대해 사용할 수 있습니다. |
| 버블 정렬 (Bubble Sort) | 인접한 두 원소를 비교하여 큰 값을 오른쪽으로 이동시키는 방식으로 정렬하는 알고리즘입니다. |
| 선택 정렬 (Selection Sort) | 주어진 배열에서 최소값을 찾아 맨 앞 원소와 교환하는 방식으로 정렬하는 알고리즘입니다. |
| 삽입 정렬 (Insertion Sort) | 정렬되어 있는 부분집합 내에서 자신이 들어갈 위치를 찾아 삽입하는 방식으로 정렬하는 알고리즘입니다. |
| 병합 정렬 (Merge Sort) | 분할 정복 방식을 이용하여 배열을 정렬하는 알고리즘입니다. |
| 힙 정렬 (Heap Sort) |	힙이라는 자료구조를 이용하여 정렬하는 알고리즘입니다. |
| 기수 정렬 (Radix Sort) | 각 자리의 숫자를 비교하여 정렬하는 알고리즘입니다. |

### 알고리즘 종류별 시간 복잡도와 최악의 시간복잡도
| 알고리즘 종류 | 평균 시간 복잡도 | 최악 시간 복잡도 |
|--------|--------|--------|
| 퀵 정렬(Quick Sort) |	O(nlogn) | O(n^2) |
| 퀵 정렬 : Arrays.sort() |	O(nlogn) | O(n^2) |
| 퀵 정렬 : Collections.sort() |	O(nlogn) |	O(n^2) |
| 버블 정렬 (Bubble Sort) |	O(n^2) |	O(n^2) |
| 선택 정렬 (Selection Sort) | O(n^2) | O(n^2) |
| 삽입 정렬 (Insertion Sort) | O(n^2) |	O(n^2) |
| 합병 정렬 (Merge Sort) | O(nlogn) | O(nlogn) |
| 힙 정렬 (Heap Sort) |	O(nlogn) | O(nlogn) |
| 기수 정렬 (Radix Sort) | O(d(n + k)) | O(d(n + k)) |

### 정렬 시간복잡도 속도 
퀵 정렬(Quick Sort) > 퀵 정렬 : ArraySort() > 퀵 정렬 : Collection.sort() > 버블 정렬(Bubble Sort) > 선택 정렬(Selection Sort) > 삽입 정렬(Insertion Sort) > 병합 정렬(Merge Sort) > 힙 정렬(Heap Sort) > 기수 정렬 (Radix Sort)

### 퀵 정렬 | 실행 시간: 평균 O(n logn), 최악 O(n^2), 메모리 : O(log n)
분할 정복(Divided and Conquer) 방법을 사용하여 구현된 정렬 알고리즘을 의미합니다. 대규모 데이터를 정렬하는데 매우 유용하며, 
많은 프로그래밍 언어에서도 내장된 정렬 함수에 사용하는 알고리즘 입니다.
퀵 정렬은 무작위로 선택한 pivot을 사용하여 배열을 분할하는데, 선정된 pivot보다 작은 원소들은 앞에, 큰 원소들은 뒤로 보냅니다.
배열 분할 작업은 연속된 스왑(swqp) 연산을 통해 효율적으로 수행됩니다. 

배열과 그 부분 배열을 반복적으로 분할해 나가면 결국에 배열은 정렬된 상태에 도달합니다. 하지만, 배열 분할에 사용되는 원소가 
중간값(median), 적어도 중간값에 가까운 값이 되리라는 보장이 없기 때문에, 정렬 알고리즘이 느리게 동작할수도 있습니다.
그래서 최악의 경우에 수행 시간이 O(n^2)이 될 수 있습니다.

### 동작 방식
1. 피벗을 기준으로 피벗보다 작은 요소들은 피벗의 왼쪽에 위치시키고 피벗보다 큰 요소는 오른쪽에 위치시킵니다.
2. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트 각각을 다시 정렬합니다.
   - 분할된 서브 리스트에 대해서는 순환 호출을 이용하여 정렬을 반복합니다.
   - 서브 리스트에서도 재차 피벗을 정하고 이를 기준으로 2개의 서브 리스트로 다시 나누어 주는 과정을 반복합니다.
3. 부분 리스트들이 더이상 분할이 불가능할 때까지 반복합니다.
   - 리스트의 크기가 0이나 1이 될 때까지 반복합니다.
 
그림으로 설명해보겠습니다.
1. **pivot 값을 먼저 정해준다.
pivot 값은 리스트의 가장 앞에 위치한 원소도 가능하고 가장 뒤에 위치한 원소도 가능합니다. 어느 원소로 잡아도 되지만 저는 가장 중간에
위치한 5로 잡아보겠습니다.
<img width="370" height="164" alt="image" src="https://github.com/user-attachments/assets/3372f2ee-7da1-47e9-8f01-2616f8fe4d4f" />

2. 그렇게 해서 이 pivot값을 기준으로 원소들을 재배치 한다. 재배치하는 방식은 아래와 같이 5보다 작은 값들은 왼쪽으로, 5보다 큰 값들은 오른쪽으로
이동시키는 방식.
<img width="402" height="272" alt="image" src="https://github.com/user-attachments/assets/7631c889-1655-4a1c-889b-69377aa5c9cf" />

이 때 Pivot 값의 인덱스가 바뀌는 것은 자연스로운 일로 Pivot값 자체가 중요한 것이기 때문에 크게 신경쓰지 않아도 됩니다.
이 Pivot 값을 중심으로 두 개의 서브 리스트가 생긴것입니다.

3. 이 서브 리스트들에서 각각 Pivot 값을 다시 정해줍니다.
- 저는 왼쪽 서브리스트에서는 중간 값인 1, 오른쪽 서브리스트에서는 6으로 잡았습니다.
<img width="382" height="212" alt="image" src="https://github.com/user-attachments/assets/3a39169b-ccc2-4ffe-a0f8-ceddbc178bc1" />

4. 그럼 다시 이 Pivot값을 중심으로 대소 비교를 통한 재배치 과정을 진행합니다.
여기서 오른쪽의 서브 리스트는 원소의 갯수가 하나만 남았기 때문에 더 이상 분할할 수가 없으므로 오른쪽의 퀵 정렬은 종료가 됩니다.

왼쪽의 서브 리스트는 아직 정렬할 원소가 남아있기 때문에 해당 리스트에서 Pivot 값을 정해 계속해서 정렬해주도록 하겠습니다.

pivot값을 중간값인 3으로 잡고 진행해보겠습니다.

<img width="382" height="223" alt="image" src="https://github.com/user-attachments/assets/4797e9d9-72e7-41db-9985-62e29972e65d" />

또다시 Pivot 값을 기준으로 재배치하여 분할을 진행합니다.

분할을 통해 나온 양쪽 서브 리스트 원소의 갯수가 1개씩만 남았으므로 퀵 정렬이 완전히 종료가 되고 실제로 정렬된 배열을 보면 오른차순으로 잘 정렬되었음을
볼 수 있습니다.

퀵 정렬을 움직이는 애니메이션을 통해 보면 아래와 같습니다.

여기서는 Pivot 값을 서브 리스트의 중간 값이 아니라 가장 맨 오른쪽 값으로 정하여 진행한 모습입니다. 
- 실제로 퀵 정렬을 할 때 정하는 Pivot 값을 리스트의 맨 오른쪽 값으로 정하는 경우가 많습니다.
<img width="280" height="214" alt="image" src="https://github.com/user-attachments/assets/936791e0-fc6c-4d25-8117-23b15735c25c" />

## Pivot 결정의 중요성
아래와 같은 배열을 정렬해야 한다고 하고 Pivot값을 가장 좌측에 있는 값으로 잡는다고 해봅시다.
<img width="806" height="207" alt="image" src="https://github.com/user-attachments/assets/27fa60ee-d165-4464-aceb-1ba23477d35e" />

이를 오름차순으로 정렬하려 하는데 뒤의 모든 값들이 내림차순으로 정렬되어 있고 41이 이미 가장 큰 숫자입니다. 이 상태에서 1차 정렬을 진행하면
다음과 같이 될 것입니다.
<img width="791" height="211" alt="image" src="https://github.com/user-attachments/assets/dc72b59d-a984-4a3a-8fed-d96570b2cd0f" />

이처럼 피벗의 위치를 찾았더니 모든 값과 비교하였을 때, 전부 swap이 되었을 것이고, 또 가장 마지막에 위치해 있을것입니다.

Pivot이 적당히 중간쯤에 위치했다면 양 쪽의 부분 집합이 균등하게 분배되어서 전체 비교 횟수를 월등하게 줄일 수 있었음에도 이러한 현상이 
반복되었다면 비교해야 하는 횟수는 계속해서 늘어날 수 밖에 없는것입니다. 사실상 버블 정렬과 다를게 없게 됩니다.

이런 최악의 케이스에서 시간 복잡도는 O(n^2)를 갖게 되며 퀵 정렬이 더 이상 제 기능을 하지 못하게 되는 것입니다.
그래서 이처럼 Pivot값을 어떤 것으로 잡을 지는 상황에 따라 매우 다릅니다. 항상 최우측 혹은 좌측 값을 Pivot으로 설정하는 것도 
때에 따라서는 최악의 성능을 갖게 될 수 있기 때문입니다.

아래 피벗을 정하는 두가지 방법이 있습니다.

### 1) 무작위 선택
랜덤하게 설정하면 항상 최악의 경우가 되진 않을 것입니다. 그러나 여전히 최악의 케이스가 생겨날 수 있다는 점은 사라지지 않습니다.
- 이 경우 평균적으로 )(nlog_2n)의 시간 복잡도를 유지합니다.

### 2) Median-of-3 method
이 방법은 배열의 여러 값들 중에서 가장 좌측, 우측, 중간 이렇게 3개의 값들을 뽑고, 이 3개의 값들에 대해서 정렬을 한 뒤, 그 중
중간값을 가장 좌측 또는 우측으로 이동시켜서 Pivot으로 설정하는 방법입니다.

이 값이 Pivot으로 사용되어 전체 배열을 균등하게 분할할 수 있다는 보장은 없지만, 최소한 이 값이 전체 중 최대/최소 값에는 해당되지 
않는다는 것을 보장하기 때문에 중심 극한 정리에 따라서 평균 O(nlog_2n)의 시간 복잡도를 유지할 수 있게 되는것입니다.

예를 들어, 다음과 같은 배열을 봅시다.
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
 35  33  42  10  14  19  27  44  26  31

 이 배열에서 left는 35, mid는 14, right는 31인데 정렬을 하면 right 값인 31이 median 값이 되고 이 값을 Pivot 값으로 
 사용한다는 의미입니다.

```java
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        int[] arr = { 9, 3, 5, 2, 7, 1, 6, 8, 4 }; // 예시 배열
        System.out.println("정렬 전: " + Arrays.toString(arr));

        quickSort(arr, 0, arr.length - 1);

        System.out.println("정렬 후: " + Arrays.toString(arr));
    }

    public static void quickSort(int[] arr, int low, int high) {
        if (low >= high) {
            return;
        }

        int pivot = low + (high - low) / 2;
        int pivotValue = arr[pivot];

        int left = low;
        int right = high;

        while (left <= right) {
            while (arr[left] < pivotValue) {
                left++;
            }
            while (arr[right] > pivotValue) {
                right--;
            }
            if (left <= right) {
                int tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;
                left++;
                right--;
            }
        }

        quickSort(arr, low, right);
        quickSort(arr, left, high);
    }
}

```
### 코드 설명
- 가장 먼저 quickSort도 종료 조건으로 low와 high가 같아지는 상황, 즉, 분할을 모두 마쳐 서브 리스트의 크기가 1인 상황, 즉, 원소가
  하나인 상황에 retur을 합니다.
- 이제 퀵 정렬을 시작합니다. 퀵 정렬에서는 가장 먼저 pivot값을 정해주어야 합니다. 중간값으로 pivot값을 정해주도록 합시다.
  (low + high) / 2 와 같이 해주지 않은 이유는 overflowExcpetion을 방지하기 위해서입니다.
  int형 변수의 크기 범위는 2^-31 ~ 2^31 이기 때문입니다.
- PivotValue에는 pivot 인덱스에 해당하는 Pivot값을 넣어주도록 합니다.
  우리는 이 값을 아주 중요하게 다룰 것입니다.
- left와 right에는 배열의 low(시작), high(끝)값을 각각 넣어줍니다.
- 첫 번째 while 문
  - left의 값과 right의 값이 겹치지 않을 때까지 다음 내용을 반복합니다.
  - 내부 while문 1
    - 배열의 left값이 pivot값보다 작다면 잘 배치되어 있는것으로 다음 left index를 순회해야 하기 때문에 left값을 1증가시켜 다음 인덱스로 이동합니다.
  - 내부 while문 2
    - 배열의 right값이 pivot값보다 크다면 잘 배치 되어있는것으로 다음 right 인덱스를 순회해야 하기 때문에 right 값을 1 감소시켜 다음 인덱스로 이동합    니다.
  - 만약 left와 right이 이동하다가 서로 만나게 되었거나, 서로 교차하지 않은 상황이라면 배열의 left의 값과 right의 값을 서로 바꾸어주는 과정을 진행 후
    left와 right의 인덱스를 각자 방향으로 이동시킵니다.
  - 이를 재귀함수를 통해 왼쪽과 오른쪽 각각에 대하여 퀵 정렬을 수행합니다.

이제 그림으로 설명드리겠습니다.

<img width="333" height="585" alt="image" src="https://github.com/user-attachments/assets/3d66c5c1-8f1d-4c86-a4e9-6664b668580e" />

- pivot 값이 5로 잡혔기 때문에 처음 left의 index는 0번에서 pivot이 위치한 곳까지 오게되고 right은 맨 끝에서 2가 위치한곳까지 오게됩니다.
  - left 서브 리스트의 운소는 모두 5보다 작기 때문에 pivot까지 온 것이고,
  - right 서브 리스트의 원소 중 5보다 크지 않은 2가 존재하여 해당 위치에서 멈춘 모습입니다.
- 그리고 왼쪽 인덱스와 오른쪽 인덱스가 아직 교차하지 않은 상태이므로 left와 right의 값을 바꿔줍니다.
- swap 이후 다시 while 문으로 돌아와 진행합니다.
- 이 상태에서는 left는 7을 만나 멈추고 right은 이미 pivot이기 때문에 그대로입니다.
- 이 때도 역시 left와 right index가 아직 서로 교차하기 전이므로 left와 right 값을 바꾸어 줍니다.
  그러고 나면 left와 righ가 교차하게 되어 왼쪽 리스트와 오른쪽 리스트가 pivot에 의해 정렬됩니다.
- 이를 서브 리스트의 크기가 1이 될 때까지 반복하게 됩니다.

아래 그림은 다른 예로 pivot을 맨 왼쪽으로 잡은 경우를 도식화한 것입니다.
<img width="624" height="881" alt="image" src="https://github.com/user-attachments/assets/b2cc58f9-adf3-4faf-a055-c5066f2696a3" />

## 장점과 단점
[장점]
1. 특정 상태가 아닌 이상 평균 시간 복잡도는 nlog_2n 이며, 다른 nlog_2n 알고리즘에 비해 대체적으로 속도가 매우 빠릅니다. 유사하게 nlog_2n 정렬
   알고리즘 중 분할정복 방식인 merge sort에 비해 2~3배 정도 빠릅니다.
2. 추가적인 별도의 메모리를 필요로 하지 않으며, 재귀 호출 스택프레임에 의한 공간복잡도는 log_2n 으로 메모리를 적게 소비합니다.

[단점]
1. 특정 조건하에 성능이 급격하게 떨어집니다.
   - 내림차순으로 정렬되어 있는데 pivot값을 배열의 첫 Index로 잡는 경우
   - 되도록 pivot값을 Median-Of-3 방법을 통해 잘 정하도록 하자.
2. 재귀 호출을 사용하기 때문에 재귀를 사용하지 못하는 환경일 경우 그 구현이 매우 복잡해진다.

## 퀵 정렬의 시간복잡도
- 최선의 경우
- 비교횟수
<img width="1280" height="578" alt="image" src="https://github.com/user-attachments/assets/c9ec73ec-ef8d-4b5c-8182-0e5dcfb77fdf" />

- 재귀호출의 depth
  - 레코드 개수 N이 2의 거듭제곱이라고 가정(n=2^k)했을 때, n = 2^3 인 경우,
    2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어 재귀 호출의 depth가 3인것을 확인할 수 있습니다. 이를 일반화하면 n = 2^k 인 경우,
    k(k=log_2n)임을 알 수 있습니다.
  - k = log_2n
- 각 재귀호출 단계에서의 비교 연산
  - 각 재귀호출에서는 전체 리스트의 대부분의 데이터 값을 비교해야 하므로 평균 N번 정도의 비교가 이루어집니다.  
- 재귀호출의 깊이 x 각 재귀호출 단계의 비교 연산 = nlog_2n
- 이동 횟수
  - 비교 횟수보다 적기 때문에 무시할 수 있습니다.
- 최선의 경우, 시간 복잡도 T(n) = O(nlog_2n)

- 최악의 경우 (Median of Three)
  - 리스트가 계속 불균형하게 나누어지는 경우
  - 위에서 설명한 예시에 더불어 이미 정렬되어 있는 리스트에 대하여 퀵 정렬을 실행하는 경우도 있습니다.
   <img width="413" height="364" alt="image" src="https://github.com/user-attachments/assets/738cc443-1d28-4f7d-9c6e-daffff97b620" />

- 비교 횟수
  - 재귀 호출의 depth
  - 레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, 재귀호출의 depth는 n이다.
  - n 번

- 각 순환호출 단계의 비교 연산
  - 각 순환호출에서는 전체 리스트의 대부분의 데이터 값을 비교해야 하므로 평균 n번 정도의 비교가 이루어진다.
  - 평균 n번
  - 재귀 호출의 깊이 x 각 재귀 호출 단계의 비교 연산 = n^2
- 이동 횟수
  - 비교 횟수보다 적기 때문에 무시할 수 있습니다.
- 최악의 경우, 시간복잡도 T(n) = O(n^2)

- 평균
  - 평균 T(n) = O(nlog_2n)
  - 시간 복잡도가 O(nlog_2n)를 가지는 다른 정렬 알고리즘과 비교했을때 퀵 정렬이 월등히 빠르다.
  - 퀵 정렬이 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 Pivot들이 추후 연산에서 제외되는 특성 때문이다.      

```java
void quickSort(int[] arr, int left, int right) {
  int index = partition(arr, left, right);
  if (left < index - 1) { // 왼쪽 분할
    quickSort(arr, left, index - 1);
  }
  if (index < right) { // 오른쪽 절반 정렬
    quickSort(arr, index, right);
  }
}

void swap(int[] arr, int i, int j) {
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}


int partition(int[] arr, int left, int right) {
  int pivot = arr[(left + right) / 2]; // 분할 기준 원소 선정
  while (left <= right) {
    // 왼쪽에서 오른쪽으로 옮겨야 하는 원소 탐색
    while (arr[left] < pivot) left++;

    // 오른쪽에서 왼쪽으로 옮겨야 하는 원소 탐색
    while (arr[right] > pivot) right--;

    // 원소를 스왑한 뒤 left와 right를 이동
    if (left <= right) {
      swap(arr, left, right); // 피벗 기준 좌우값 교환
      Left++;
      right--;
    }
  }

  return left; // 다음 재귀 호출을 위한 새로운 기준점 반환
}
```

```java
import java.util.*;

/*
 * 숫자 배열의 정렬
 */
Integer[] sortNumArr1 = {0, 1, 2, 3, 4};
Integer[] sortNumArr2 = {10, 11, 1, 2, 4};

// [CASE1] 숫자 오름차순 정렬 -1 : 오름차순으로 정렬이 됩니다.
Arrays.sort(sortNumArr1);   // [0, 1, 2, 3, 4]

// [CASE2] 숫자 오름차순 정렬 -2 : 오름차순으로 정렬이 됩니다.
Arrays.sort(sortNumArr1, Comparator.naturalOrder()); // [0, 1, 2, 3, 4]

// [CASE3] 숫자 내림차순 정렬 -1 : 내림차순으로 정렬이 됩니다.(* 해당 주의 사항은 Wrapper Class 를 이용하여야 합니다.)
Arrays.sort(sortNumArr1, Collections.reverseOrder());   // [4, 3, 2, 1, 0]

// [CASE4] 숫자 내림차순 정렬 -2 : 내림차순으로 정렬이 됩니다.(* 해당 주의 사항은 Wrapper Class 를 이용하여야 합니다.)
Arrays.sort(sortNumArr1, Comparator.reverseOrder());   // [4, 3, 2, 1, 0]

/*
 * 문자열의 정렬-1 : 대소문자를 구분하여 정렬하는 방식
 */
String[] sortStrArr1 = {"strawberry", "Strawberry", "mango", "Mango", "cherry", "Cherry", "banana", "Banana", "apple", "Apple"};

// [CASE1] 문자 정렬 : 오름차순으로 정렬합니다.
Arrays.sort(sortStrArr1);                                           // [Apple, Banana, Cherry, Mango, Strawberry, apple, banana, cherry, mango, strawberry]

// [CASE2] 문자 정렬 : 내림차순으로 정렬이 됩니다. (* 해당 주의 사항은 Wrapper Class 를 이용하여야 합니다.)
Arrays.sort(sortStrArr1, Collections.reverseOrder());               // [strawberry, mango, cherry, banana, apple, Strawberry, Mango, Cherry, Banana, Apple]
```
### 버블 정렬(bubble sort) | 평균 및 최악 실행 시간: O(n^2), 메모리: O(1)
버블 정렬은 배열의 첫 원소부터 순차적으로 진행하며, 현재 원소가 그 다음 원소의 값보다 크면 두 원소를 바꾸는 작업을 반복합니다. 이런 식으로
배열을 계속 살펴보면서 완전히 정렬된 상태가 될 때까지 반복합니다.

<img width="401" height="141" alt="image" src="https://github.com/user-attachments/assets/176946ae-9386-4310-bd17-34dfb55a1bb3" />

아래에 정렬되지 않은 리스트가 있습니다.

<img width="360" height="69" alt="image" src="https://github.com/user-attachments/assets/5f5310d4-7ef1-4adf-a002-dbee0e6bdc5b" />

우선 가장 앞에 위치한 두 개의 값을 비교하게 됩니다. 그래서 만약 정렬되어 있지 않다면, 즉 다시 말해서 왼쪽의 값이 오른쪽보다 크다면 두 숫자를
바꿔주게 됩니다.

위 그림에서는 첫 비교가 5와 4이기 때문에 5와 4를 비교했을 때, 왼쪽 값이 더 크기 때문에 두 값의 위치를 바꾸어줍니다.
<img width="353" height="76" alt="image" src="https://github.com/user-attachments/assets/2d9304ae-b8cc-4a17-b643-593e10b6baec" />

그 다음 5와 1을 비교 연산하여 이 역시도 위치가 바뀌게 되고 이런 방식으로 한 칸 씩 계속 옮겨각며 정렬을 진행해 줍니다.
<img width="355" height="127" alt="image" src="https://github.com/user-attachments/assets/9594844c-5e2f-4514-8483-7df9b8ec9ead" />

이 연산을 리스트의 가장 끝까지 진행하게 되면 다음과 같은 그림처럼 됩니다.

<img width="360" height="78" alt="image" src="https://github.com/user-attachments/assets/e8d086d1-d483-4a0e-a16e-20732a04b734" />

한 Cycle을 진행할때는 리스트 크기보다 1작은 index까지 진행해야 합니다.
- 배열의 마지막 index는 비교할 다음 인덱스가 없기 때문

하지만 이 값을 제외한 앞의 값들을 여전히 정렬되지 않은 상태입니다. 따라서 버블 정렬로 cycle 정렬을 하더라도 완전히 정렬되지 않을 수 있는 것입니다.

<img width="346" height="105" alt="image" src="https://github.com/user-attachments/assets/32ff1a0f-e984-481d-8318-59882459c00e" />

그렇다면, 다시 처음부터 버블 정렬을 시작합니다. (2cycle). 그러면 또 마지막을 제외한 index까지 정렬을 하면 다음과 같이 남은 데이터들 중
가장 큰 수가 마지막에서 두 번째에 위치하게 될것입니다.

<img width="353" height="72" alt="image" src="https://github.com/user-attachments/assets/d82a3b0f-548a-47f1-b0fd-f1cd4aa2cda6" />

그렇게 해서 한 Cycle을 마무리 할 때마다 남은 리스트에서 가장 큰 값이 뒤부터 하나씩 채워지게 됩니다. 다음 그림을 봅시다.

<img width="353" height="77" alt="image" src="https://github.com/user-attachments/assets/c147d28f-d568-4a39-8195-2a33192bb63b" />
위와 같은 과정으로 진행되어 남은 리스트의 데이터가 하나 남았을때는 더 이상 정렬할 것이 없는 것으로 보고 모든 값들이 정렬이 된 상태가 됩니다.

### 버블 정렬의 진행 과정
- 인접한 두 element 값을 비교합니다.
- 두 값이 정렬되어 있지 않다면(즉, 왼쪽 값 > 오른쪽 값이면 ) 두 element의 위치를 교환합니다.
- 정렬이 완료된 element를 제외하고 위의 과정을 계속 반복합니다.
  - 만약 처음에 배열의 크기가 3이라면 2번 비교를 하게 되고, 4이면 3번 비교를 하기 때문에 n개의 데이터가 있다면 n - 1번 비교를 하게 됩니다.
    그 후로 데이터가 하나씩 줄어들기 때문에 n - 2, n - 3, , ..., 2, 1 번의 순서대로 비교를 하게 되는 것입니다.
    이는 식으로 나타내면 다음과 같습니다.
  - (n - 1) + (n - 2) + (n - 3) + ... + 2 + 1 = n*(n - 1) / 2
- 위 식을 통해 리스트의 맨 마지막 자리에 가장 큰 수가 들어가게 됩니다.

<img width="280" height="237" alt="image" src="https://blog.kakaocdn.net/dna/bf5RzX/btrU0utjRtT/AAAAAAAAAAAAAAAAAAAAAKjuZ6p4OZaLnEySb_0hykJ2odkNlI_4ZbqwbUwJ0Zdu/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=oVRhDLh4XYxcEdL%2Bv1abIyQ6CHo%3D" />

출처 : 위키 백과https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC

버블 정렬이라는 이름은 버블 정렬 애니메이션을 보면 위와 같이 **정렬되는 모습이 마치 거품과 같다** 하여 버블 정렬로 불리게 된 것입니다. 또한 시간복잡도는 O(N^2) 형태이지만 직관적이고 단순한 알고리즘이기에 꽤 많이 쓰이는 정렬 중에 하나입니다.

### 버블 정렬 구현
```java
import.java.util.Arrays;

public class BubbleSortExample {
  public static void bubbleSort(int[] arr) {
      int n = arr.length;
      bollean swapped;
      
      for (int i = 0; i < n - 1; i++) {
          swapped = false;
          
          // 마지막 i개의 원소는 이미 정렬되어 있으므로 제외
          for (int j = 0; j < n - 1; j++) {
              if (arr[j] > arr[j + 1]) {
                  //swap
                  int temp = arr[j];
                  arr[j] = arr[j + 1];
                  arr[j + 1] = temp;
                  swapped = true;
              }
          }
          
          // 한 번도 스왑되지 않았다면 이미 정렬된 상태
          if (!swapped) break;
      }
  }
  
  public static void main(String[] args) {
      int[] data = {5, 3, 8, 4, 2};
      System.out.System.out.println("정렬전: " + java.util.Arrays.toString(data));
      bubbleSort(data);
      System.out.System.out.println("정렬후: " + java.util.Arrays.toString(data));
  }
}
```

### 코드 설명
- for (int i = 0; i < n - 1; i++) : 총 n - 1 번 반복 (가장 큰 수부터 뒤로 보냄)
- 중찹 루프에서 바깥 루프는 전체 리스트에 대해 반복하는 것이고, 내부루프 j는 아직 정렬되지 않은 범위(정렬된 리스트 제외)를 반복하는것
- 그렇기 때문에 0부터 arr.length - 1 - i 만큼 반복을 해야지 i값이 늘어남에 따라 고정된 데이터가 늘어나는 것이기 때문에 반대로
  순회해야 하는 리스트의 크기는 그만큼 줄어들게 되는 것입니다.
- 그 후 안쪽 for 문에서 if 문으로 왼쪽 값이 오른쪽 값보다 크게 되면 정렬을 진행해줍니다. (swap)
- swapped 플래그는 정렬이 일어났는지 여부 확인. 성능 최적화를 위해 사용됩니다.
- 정렬이 이미 끝났다면 조기 종료합니다.

### 버블 정렬의 특징
**[장점]
- 구현이 정렬 중에서 가장 단순합니다
  
**[단점]
- 순서에 맞지 않는 element를 인접한 element와 교환합니다.
- 하나의 element가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 합니다.
- 특히, 특정 요소가 가장 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어납니다.

일반적으로 자료의 교환(swap) 작업이 자료의 이동 작업(move)보다 더 복잡하기 때문에 버블정렬은 단순함에도 불구하고 잘 쓰이지는 않습니다.

### 시간 복잡도
- 비교 횟수
  - 최상, 평균, 최악 모두 일정
  - n - 1, n - 2, ..., 2, 1번 = n(n - 1) / 2

- 교환(swap) 횟수
  - 만약 최악의 경우, 입력 자료가 역순으로 정렬되어 있다면 한 번 교환하기 위해서 3번의 교환이 필요하기 때문에 (비교 횟수 * 3)번 입니다.
- 시간 복잡도(T(n)) = O(n^2)

### 선택 정렬


### 기수 정렬(radix sort) | 실행 시간 : O(kn)
기수 정렬은 Queue를 사용해서, 각 자릿수를 기준으로 정렬하는 과정을 반복하는 알고리즘입니다. 기수 정렬 알고리즘은 데이터가
정수(다른 형태의 데이터에 대해서도 마찬가지지만)처럼 유한한 비트로 구성되어 있는 경우에 사용됩니다. 기수 정렬은 각 자릿수를
순회해 나가면서 각 자리의 값에 따라 그룹을 나눕니다. 가령 정수 배열이 주어졌다고 하면 처음에는 첫 번째 자릿수를 기준으로
정렬합니다. 따라서 첫 번째 자릿수가 0인 수들은 같은 그룹에 속합니다. 그런 다음 각 그룹마다 두 번째 자릿수를 기준으로 다시
정렬을 수행합니다. 이 작업을 배열 전체가 정렬될때까지 모든 자릿수에 대해 반복합니다. 비교 연산을 사용하는 정렬 알고리즘은 평균
적으로 O(n logn)보다 나은 성능을 보일 수 없으나, 기수 정렬의 수행 시간은 O(kn)이 됩니다. 여기서 n은 정렬 대상 원소의
갯수이고, k는 자릿수의 갯수입니다. 

### 작동 방식
1. 정렬할 요소들을 가장 낮은 자릿수부터 가장 높은 자릿수까지 반복적으로 정렬합니다.
2. 각 자릿수에 대해 요소들을 해당 자릿수의 값에 따라 그룹화합니다.
3. 그룹화된 요소들을 순서대로 다시 배열합니다.
4. 위의 과정을 가장 높은 자릿수까지 반복하여 정렬이 완료될때까지 진행합니다.
<img width="654" height="320" alt="image" src="https://github.com/user-attachments/assets/24da4281-d297-49bb-927e-d76d64d2c506" />
https://www.ritambhara.in/radix-sort/

### Selection Sort[선택 정렬]
선택 정렬은 말 그대로 현재 위치에 들어갈 데이터를 찾아 선택하는 알고리즘입니다. 데이터를 **비교** 하면서 찾기 때문에 **비교 정렬** 이며
정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 **제자리 정렬(in-place-sort)** 이기도 합니다. 정확히는 데이터를
서로 교환하는 과정(swap)에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 보는 것입니다. 그리고 
**불안정 정렬** 입니다.

### 선택정렬 동작 방식 

1. 주어진 리스트에서 최솟값을 찾는다
2. 최솟값을 맨 앞자리의 값과 교환한다
3. 맨 앞 자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다

그림으로 보면 아래와 같습니다.

<img width="1280" height="1231" alt="image" src="https://github.com/user-attachments/assets/7127e694-2430-4750-bd65-cd5a5f005b13" />

마지막 round9를 안하는 이유는 앞 인덱스부터 순차적으로 정렬해나가기 때문에 N개의 데이터 중 N - 1개가 정렬 되어있다는 것은 결국 마지막 원소가 
최댓값이라는 말이고, 이는 정렬이 되어있다는 상태이므로 굳이 참조를 해줄 필요가 없다.

<img width="100" height="371" alt="image" src="https://blog.kakaocdn.net/dna/qjbEC/btqNiW4IUsW/AAAAAAAAAAAAAAAAAAAAAJccqWZaRFg10FZaFEyAhWG3gfDIZDAihQjiYdSCocSR/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=iFiYabqLgobEClXUJh8VDfOHLTs%3D" />
출처 : https://en.wikipedia.org/wiki/Selection_sort

<img width="288" height="288" alt="image" src="https://blog.kakaocdn.net/dna/bgt07W/btqNhavti2h/AAAAAAAAAAAAAAAAAAAAAH9iakvAV6cpK-YgWYt4tjCP-IB0W0qhFcubsuSLjMQl/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=KsfrahQsAtXhbAgiuyk8WcuUEmU%3D" />
출처: https://ko.wikipedia.org/wiki/선택_정렬

### Selection Sort 구현
```java
import java.util.Arrays;

public class SelectionSortExample {

    public static void main(String[] args) {
        int[] arr = {29, 10, 14, 37, 13};
        selectionSort(arr);
        System.out.println("Sorted array: " + Arrays.toString(arr));
    }

    // 선택 정렬 함수
    public static void selectionSort(int[] arr) {
        int n = arr.length;

        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;

            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }

            swap(arr, i, minIndex); // swap 함수 호출
        }
    }

    // swap 함수 정의
    public static void swap(int[] arr, int i, int j) {
        if (i == j) return; // 같은 위치면 교환 필요 없음
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
**[장점]
추가적인 메모리 소비가 적다

[단점]
1. 시간복잡도가 O(N^2)
2. 안정 정렬이 아님

단점에 대해 짚고 넘어가보겠습니다.
기본적으로 선택 정렬은 O(N^2)의 시간복잡도를 보입니다.

공식을 유도해보자면 N이 정렬해야하는 리스트의 자료 수, i가 교환되는 인덱스라고 할 때 loop을 생각해봅시다.

i = 1 일때, 데이터 비교 횟수는 N - 1 번
i = 2 일때, 데이터 비교 횟수는 N - 2 번
i = 3 일때, 데이터 비교 횟수는 N - 3 번
...
i = N - 1 일 때, 데이터 비교 횟수는 1 번ㄴ
즉, 다음과 같이 공식화 할 수 있습니다.

<img width="768" height="430" alt="image" src="https://github.com/user-attachments/assets/68a329a1-e965-4470-ba69-2640ede027d6" />

그리고 모든 N에 대하여 다음을 만족하기 때문에 시간복잡도 또한 도출할수 있습니다.

<img width="348" height="220" alt="image" src="https://github.com/user-attachments/assets/776620dd-d430-4c4e-bd11-a635c019b570" />

물론 Bubble Sort 와 이론상 같은 시간복잡도를 갖음에도 **비교 수행이 상대적으로 적기 때문에 조금 더 빠르긴 하나 그럼에도 좋은 알고리즘인 것은 아닙니다. **

두 번째 단점은 안정 정렬이 아니라는 점입니다. 즉, Stable 하지 않다는 것. 간단한 예를 들어보겠습니다. 우리는 다음과 같은 배열을 정렬하고자 합니다.

**[B1, B2, C, A] (A < B < C)
주의해서 볼 점은 B에 붙어있는 숫자는 임의로 붙인 숫자입니다. B1이 B2 보다 크거나 작은 것이 아니라는 점 유의하길 바랍니다.

그럼 순서대로 순회하면서 교환한다면 이렇습니다.

round 1 : [A, B2, C, B1]

round 2 : [A, B2, C, B1]

round 3 : [A, B2, B1, C]

이렇게 초기의 B1, B2의 순서가 뒤바뀐것을 볼 수 있습니다. 이러한 상태를 불안정 정렬이라고 하는데 문제가 되는 이유는 예를 들어 학생을 관리하고자 할 때,
성적순으로 나열하되, 성적이 같으면 이름을 기준으로 정렬하고 싶다고 할 때, 즉, 정렬 규칙이 다수이거나 특정 순서를 유지해야 할 때 문제가 발생할 수 있습니다.

[(가영, 60), (가희, 60), (찬호, 70), (동우, 45)] 이렇게 리스트가 존재한다고 생각해봅시다. 성적순이되, 성적이 같다면 이름순으로 정렬해야 한다고
했습니다.

그러면 보통 이름을 일단 정렬을 해놓을 것입니다.

<이름 정렬 순>

[(가영, 60), (가희, 60), (동우, 45), (찬호, 70)]

그 다음에 '성적 순'으로 정렬 할 것입니다. 만약 선택 정렬을 하면 어떻게 되는지 봅시다.

round 1 : [(동우, 45), (가희, 60), (가영, 60), (찬호, 70)]

round 2: [(동우, 45), (가희, 60), (가영, 60), (찬호, 70)]

round 3: [(동우, 45), (가희, 60), (가영, 60), (찬호, 70)]

 

이렇게 '가희'보다 '가영'이 앞에 있어야 함에도 순서가 바뀌어 버린 것을 볼 수 있습니다.


### 탐색 알고리즘
탐색 알고리즘 하면 일반적으로 이진 탐색(binary search)가 떠오릅니다. 실제로 이진 탐색은 공부하기 굉장히 좋은 알고리즘입니다.
이진 탐색은 정렬된 배열에서 원소 x를 찾고자 할 때 사용합니다. x를 중간에 위치한 원소와 비교한 뒤 x가 중간에 위치한 값보다 
작다면 배열의 왼쪽 절반을 재탐색하고, 크다면 배열의 오른쪽 절반을 재탐색 합니다. 이 과정을 x를 찾거나 부분 배열의 크기가 0이 
될때까지 반복합니다. 개념 자체는 꽤 간단하지만 세부적인 부분까지 자세히 따지다 보면 생각보다 구현이 어려울 수 있습니다.
아래 코드를 보면서 +1과 -1이 어떻게 사용되었는지 눈여겨보길 바랍니다.

### Insertion Sort(삽입 정렬) | 평균 및 최악 실행시간 : O(N^2), 메모리 : O(1)
삽입 정렬은 현재 비교하고자 하는 target과 그 이전의 원소듥롸 비교하며 자리를 교환(swap)하는 정렬 방법입니다.

삽입 정렬은 데이터를 **비교**하면서 찾기 때문에 **비교정렬** 이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 
**제자리 정렬(in-place-sort)**이기도 합니다. 정확히는 데이터를 서로 교환하는 과정(swap)에서 임시 변수를 필요로 하나, 이는 충분히 무시
해도 될만큼 적은 양이기 때문에 제자리 정렬로 보는 것입니다. 이는 선택정렬과도 같은 부분입니다. 그리고 선택정렬과는 달리 삽입 정렬은 **안정 정렬** 
입니다.

### 동작 방식
삽입 정렬의 경우 원리 자체는 간단합니다. 앞에서부터 해당 원소가 위치 할 곳을 탐색하고 해당 위치에 삽입하는 것입니다. 

1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다. (첫번째 타깃은 두번째 원소부터 시작합니다.)
2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.

그림으로 보면 아래와 같습니다.

<img width="1280" height="1718" alt="image" src="https://github.com/user-attachments/assets/5edf1672-441a-4d35-bfa7-af172e805bff" />

첫 번째 원소는 타겟이 되어도 비교할 원소가 없기 때문에 처음 원소부터 타겟이 될 필요가 없고, 두 번째 원소부터 타겟이 되면 됩니다.
<img width="300" height="180" alt="image" src="https://blog.kakaocdn.net/dna/bxvpd6/btqOuH69gZU/AAAAAAAAAAAAAAAAAAAAAJIwk5EhLcgsTgy00Oh4OIV0SksoH6Seze7W_QMrddX-/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=JGPZdsOkhYDDqdoVES9x38uD3Tg%3D" />
출처: https://en.wikipedia.org/wiki/Insertion_sort

<img width="280" height="237" alt="image" src="https://blog.kakaocdn.net/dna/K4Jt3/btqOvfCAm1O/AAAAAAAAAAAAAAAAAAAAACdCqKVSpINHneW6MvzgyupJgPSzHGEWMHJGxRaiiS1y/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=WBj17TwRrXBegfVnuFpAHbkw8XI%3D" />
출처: https://ko.wikipedia.org/wiki/삽입_정렬

### 삽입 정렬 구현
```java
public class Insertion_Sort {

  public static void insertion_sort(int[] a) {
    insertion_sort(a, a.length);
  }

  public static void main(int [] a, int size) {

    for(int i = 1; i < size; i++) {
      // 타겟 넘버
      int target = a[i];

      int j = i - 1;

    // 타겟이 이전 원소보다 크기 전까지 반복
    while(j >= 0 && target < a[j]) {
        a[j + 1] = a[j];
        j--;
      }

			/*
			 * 위 반복문에서 탈출 하는 경우 앞의 원소가 타겟보다 작다는 의미이므로
			 * 타겟 원소는 j번째 원소 뒤에 와야한다.
			 * 그러므로 타겟은 j + 1 에 위치하게 된다.
			 */
			a[j + 1] = target;	
    }
  }
}
```
결과적으로 타겟 이전 원소가 타겟 숫자보다 크기 직전까지 모든 수를 뒤로 한칸씩 밀어내는 것입니다.

### 삽입정렬의 장단점
**[장점]
1. 추가적인 메모리 소비가 적다.
2. 거의 정렬된 경우 매우 효율적이다. 즉, 최선의 경우 O(N)의 시간 복잡도를 갖는다.
3. 안정정렬이 가능하다.

**[단점]
1. 역순에 가까울 수록 매우 비효율적이다. 즉, 최악의 경우 O(N^2)의 시간 복잡도를 갖는다.
2. 데이터의 상태에 따라서 성능 편차가 매우 크다..

시간복잡도에 대해 잠깐 언급하자면, 위 알고리즘에서도 볼 수 있듯, 타겟 숫자가 이전 숫자보다 크기 전까지 반복하기 때문에 이미 정렬이 되어있는
경우 항상 타겟숫자가 이전 숫자보다 큽니다. 즉, 값을 N번만 비교하기 때문에 최선의 경우 O(N)의 시간복잡도를 갖게 되는것입니다.

반대로 최악의 경우는 타겟 숫자가 이전 숫자보다 항상 작기 때문에 결국 N번째 숫자에 대하어 N - 1번을 비교해야 합니다. 그렇기 때문에 최악의 경우는
O(N^2)의 시간복잡도를 가집니다.

그럼 평균 시간복잡도는? 이라는 질문이라면 삽입 정렬의 평균 시간복잡도 또한 O(N^2)의 시간 복잡도를 가집니다. 

공식을 유도해보자면 이렇습니다. 이미 최선의 경우는 O(N)인 것을 알았으니 최악의 경우를 봅시다. N이 정렬해야 하는 리스트의 자료 수, i가 타겟이
되는 인덱스라고 할 때, loop를 생각해봅시다.

i = 2 일 때, 데이터 비교 횟수는 2 - 1 = 1번
i = 3 일 때, 데이터 비교 횟수는 3 - 1 = 2번
i = 4 일 때, 데이터 비교 횟수는 4 - 1 = 3번
...
i = N 일 때, 데이터 비교 횟수는 N - 1 번

즉, 다음과 같이 공식화할 수 있습니다.

<img width="772" height="440" alt="image" src="https://github.com/user-attachments/assets/c6c63f59-3af1-4bb1-bf58-252e18ddc5c4" />

그리고 N에 대하여 다음을 만족하기 때문에 시간복잡도 또한 도출할 수 있습니다.

<img width="348" height="220" alt="image" src="https://github.com/user-attachments/assets/cf6695e1-3d45-4735-8dda-2cb3cf16a61e" />

자, 그럼 최악과 최선의 경우를 합쳐서 2로 나누면 평균이지 않겠습니까? 결과적으로 시간복잡도는 상한선을 의미하기 때문에 아래와 같은 결과를 도출할 수 
있습니다.

<img width="952" height="336" alt="image" src="https://github.com/user-attachments/assets/c4b8a7e1-43df-44e8-9778-b6fd8a5b5b28" />

결과적으로 최상의 경우와 최악의 경우의 평균으로 보더라도 **상한선** 이라는 개념에 의해 O(N^2)이 정설로 보고 있습니다.

물론 Bubble Sort나 Selection Sort와 이론상 같은 시간복잡도를 갖음에도 평균 비교 횟수에 비해 대한 기댓값이 상대적으로 적기 때문에 
**평균 시간복잡도가 O(N^2)인 정렬 알고리즘 중에서는 빠른편에 속하는 알고리즘 입니다.**

삽입 정렬의 경우 거의 정렬된 배열에서 좋은 성능을 보이기 때문에 실제로 병합정렬과 삽입 정렬을 혼합한 Tim Sort가 있습니다. 또한, 이 팀 정렬이
프로그래밍 언어에서도 자체 라이브러리로 정렬 알고리즘에 적용하고 있는 언어들이 있습니다.

이후 Tim Sort를 배울 때, 삽입 정렬도 다루게 되니 잘 기억해둬야 합니다. 
그리고 삽입 정렬을 변형하여 만든 Shell Sort도 있으니 미리 알아두는게 좋스ㅡㅂ니다.

```java
int binarySearch(int[] a, int x) {
  int low = 0;
  int high = a.length - 1;
  int mid;
  while (low <= high) {
    mid = (low + high) / 2;
    if (a[mid] < x) {
      low = mid + 1;
    } else if (a[mid] > x) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return - 1; // 에러
}

int binarySearchRecursive(int[] a, int x, int low, int high) {
  if (low > high) return - 1; // 에러

  int mid = (low + high) / 2;
  if (a[mid] < x) {
    return binarySearchRecursive(a, x, mid + 1, high);
  } else if (a[mid] > x) {
    return binarySearchRecursive(a, x, low, mid - 1);
  } else {
    return mid;
  }
}
```

### Merge Sort(병합 정렬) | 평균 및 최악 실행 시간 : O(nlog n), 메모리 : 상황에 따라 다름
병합 정렬은 배열을 절반씩 나누어 각각을 정렬한 다음 이 둘을 합쳐서 다시 정렬하는 방법입니다. 나눈 절반을 정렬할 때도 같은 알고리즘이 사용되고
결국에는 원소 한 개짜리 배열 두 개를 병합하게 됩니다. 이 알고리즘에서는 **병합**을 처리하는 것이 가장 복잡합니다.
병합 작업을 수행하는 메서드는 병합 대상이 되는 배열의 두 부분을 임시 배열(helper)에 복사하고, 왼쪽 절반의 시작 지점(helperLeft)과 
오른쪽 절반의 시작 지점(helperRight)을 추적합니다. 그런 다음 helper를 순회하면서 두 배열에서 더 작은 값의 원소를 꺼내어 원래 배열에
복사해 넣습니다. 두 배열 중 한 배열에 대한 순회가 끝난 경우에는 다른 배ㅐ열의 남은 부분을 원래 배열에 남김없이 복사해 넣고 작업을 마칩니다.

<img width="283" height="283" alt="image" src="https://blog.kakaocdn.net/dna/pMHQw/btrVoFGMKfy/AAAAAAAAAAAAAAAAAAAAABQrD3Pg-lXnPD04Gr8Smm6NtejiUVti3ywZoKDCjgHo/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=jTGHTRoT92BmESGqfhPGhRMJkOI%3D" />

### 동작 과정
1. 리스트의 크기가 0또는 1이면 이미 정렬된 것으로 본다.
2. 1번에 해당하지 않고 정렬되지 않은 리스트는 절반으로 균등하거나 비슷한 크기의 두 부분의 리스트로 잘 나눕니다.
3. 각 서브 리스트를 재귀적으로 합병 정렬을 이용해 정렬합니다.
4. 두 서브 리스트를 다시 하나의 정렬된 리스트로 합병합니다.

아래 그림은 합병정렬의 과정을 도식화 한것입니다.
<img width="1280" height="802" alt="image" src="https://github.com/user-attachments/assets/bc79e5b0-f3aa-4dc3-b518-10400209b5cc" />

### 합병 정렬의 방식
하나의 리스트를 두 개의 균등한 크기의 서브 리스트로 분할하고 분할 된 리스트를 정렬한 다음, 이 두 정렬된 서브 리스트를 합쳐서 정렬된 전체의 리스트가
되게끔 하는 방법입니다.

합병 정렬은 다음과 같은 단계들로 이루어져 있습니다.
- 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할합니다.
- 정복(Conquer): 부분 배열을 정렬합니다. 부분 배열의 크기가 조금 큰 편이라고 생각이 들면 재귀호출을 통해 다시 분할 정복 방법을 진행합니다.

### 합병 정렬 - Merge Sort
아래 그림처럼 정렬되기 전의 리스트가 있다고 가정합니다. 이 리스트를 크기가 같은 두 개의 리스트로 분할합니다.

<img width="570" height="168" alt="image" src="https://github.com/user-attachments/assets/83b0ab6c-4696-4e75-a371-cc37f27256cd" />

여기서 이 서브 리스트들은 또 다시 같은 크기의 서브 리스트로 분할합니다.

<img width="602" height="259" alt="image" src="https://github.com/user-attachments/assets/6721427c-5e7f-4791-b009-47eefee6fa75" />

이 과정을 가장 하위의 서브 리스트의 크기가 1이 될 때까지 반복합니다. 현재 하위 서브 리스트의 크기는 2이므로 이 과정을 한 번 더 반복해줍니다.

<img width="644" height="309" alt="image" src="https://github.com/user-attachments/assets/6bd8a4cb-33dc-4a62-b67c-be1b8390b9f8" />

이제 크기가 1인 8개의 서브 리스트들로 분할되었습니다.

<img width="620" height="96" alt="image" src="https://github.com/user-attachments/assets/d2e1ea78-a6b8-40ee-8016-a15856e3c1b2" />

이제 이 분할된 부분 리스트들을 정렬하면서 다시 합쳐주는 과정(combine)을 진행합니다. 크기가 1인 부분 리스트들을 정렬하여 크기가 2인 부분리스트로
다시 합칩니다. 이때, 합치면서 각 원소들은 자신의 위치로 정렬이 되기 때문에 합쳐진 서브리스트들은 항상 정렬된 상태를 유지하게 됩니다.

<img width="609" height="158" alt="image" src="https://github.com/user-attachments/assets/2318be7a-9c66-4d2e-b904-9fcbbc10d990" />

이 과정을 모든 서브 리스트들이 하나의 리스트가 될 때까지 반복해 줍니다. 다음 그림은 이 과정을 반복한 것입니다.

<img width="630" height="338" alt="image" src="https://github.com/user-attachments/assets/412ae646-e87e-497d-a12e-b7740d0283ad" />

결과적으로 마지막에 합치는 과정에서 크기가 8인 정렬된 리스트를 얻을 수 있습니다.

### 분할 정복 알고리즘
<img width="300" height="180" alt="image" src="https://blog.kakaocdn.net/dna/bK0V9i/btrVkewouTx/AAAAAAAAAAAAAAAAAAAAACaxqvkyF1VIUzZfuWaq-3SUUoWWrqU6gDbNw9JIHHom/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=3fgPmGBy4QYEHRgsMiDtDHFZSgk%3D" />

이렇게 하나의 문제를 동일한 유형의 작은 문제들로 분할한 다음, 작은 문제에 대한 결과들을 조합해서 큰 문제들을 해결하는 알고리즘을 **분할 정복(Divide and Conquer)** 이라고 합니다. 이 분할 정복은 알고리즘 풀이에 있어서 적지 않게 사용되고 보통 재귀함수로 구현이 됩니다. 그러한 이유로 merge sort 또한
재귀 함수로 구현을 할 것입니다.

#### 시간 복잡도
O(NlogN)
<img width="539" height="379" alt="image" src="https://github.com/user-attachments/assets/2be5b490-b7a3-4c32-9135-2ff08f3f6d8f" />

우선 분할 과정에서 리스트의 크기가 1/2씩 감소하게 됩니다. 그래서 처음 N개의 리스트에서 분할을 진행하면 N/2 크기의 서브 리스트 2개를 얻게 되고
이 상태에서 분할을 다시 진행하게 되면 N/4 크기의 서브리스트 4개를 얻게 됩니다.

이러한 분할 연산을 모든 서브리스트들의 크기가 1이 될 때까지 반복해야 하는데 리스트의 크기가 2라면 1번, 4개라면 2번, 8개라면 3번을 반복해야
크기가 1인 리스트를 얻을 수 있습니다.

따라서, 분할 과정에서 O(log_2N)의 시간 복잡도를 갖게 됩니다.

<img width="553" height="373" alt="image" src="https://github.com/user-attachments/assets/7bf9f1dc-7d5d-4d3a-bf79-fa98f0045dfb" />

또한 분할된 상태에서 리스트들을 다시 합칠 때(합병.Merge) 각 element들을 비교하면서 진행되기 때문에 리스트의 크기가 1인 상태일때 총 n개의
리스트가 있을 것이므로, 이 때, n번의 비교연산을 수행하게 됩니다.

이 후 합쳐진 상태에서 리스트의 크기가 n/4 이고, 갯수가 4개라면 또 다시 n 번의 비교연산이 필요합니다. 결국 각 depth에서 n번 비교 연산을
갖게 되고 이는 O(n)의 시간복잡도를 요구하게 됩니다.

<img width="590" height="359" alt="image" src="https://github.com/user-attachments/assets/52624795-ccb2-46d6-9f74-5d6dc4234cd6" />

따라서 결과적으로 merge sort의 시간 복잡도는 분할과 합병과정을 합친 O(Nlog_2N)의 시간복잡도를 갖게 됩니다.

```java
import java.util.Arrays;

public class MergeSortExample {

    public static void main(String[] args) {
        int[] arr = {38, 27, 43, 3, 9, 82, 10};
        System.out.println("Original array: " + Arrays.toString(arr));
        mergeSort(arr, 0, arr.length - 1);
        System.out.println("Sorted array:   " + Arrays.toString(arr));
    }

    // 🔹 병합 정렬 함수
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            // 1. 분할 단계
            int mid = (left + right) / 2;

            mergeSort(arr, left, mid);       // 왼쪽 절반 정렬
            mergeSort(arr, mid + 1, right);  // 오른쪽 절반 정렬

            // 2. 합병 단계
            merge(arr, left, mid, right);
        }
    }

    // 🔹 병합 함수
    public static void merge(int[] arr, int left, int mid, int right) {
        // 배열의 길이 계산
        int n1 = mid - left + 1;
        int n2 = right - mid;

        // 임시 배열 생성
        int[] L = new int[n1];
        int[] R = new int[n2];

        // 데이터 복사
        for (int i = 0; i < n1; i++)
            L[i] = arr[left + i];
        for (int j = 0; j < n2; j++)
            R[j] = arr[mid + 1 + j];

        // 실제 병합 과정
        int i = 0, j = 0, k = left;

        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k++] = L[i++];
            } else {
                arr[k++] = R[j++];
            }
        }

        // 남은 원소 복사
        while (i < n1) {
            arr[k++] = L[i++];
        }
        while (j < n2) {
            arr[k++] = R[j++];
        }
    }
}

```

<img width="815" height="781" alt="image" src="https://github.com/user-attachments/assets/c347a694-575c-46a9-89e8-36e34a5f7211" />

### 합병 정렬의 시간 복잡도
- 분할 단계
  비교 연산과 이동 연산이 수행되지 않는다
  
- 합병 단계
  - 비교 횟수
<img width="1084" height="488" alt="image" src="https://github.com/user-attachments/assets/2137e523-f832-4ec0-804d-92d04f107e5a" />

- 재귀 호출의 depth (합병 단계의 수)
  - 데이터의 개수 N이 2의 거듭제곱이라고 가정(n=2^k) 했을때, n = 2^3 의 경우, n = 2^3 -> n=2^2 -> n=2^2 -> n=2^0
    순으로 줄어들어 순환호출의 깊이가 3임을 알 수 있다. 이것을 일반화하면 n=n=2^k 경우, k(k=log_2n)임을 알 수 있다.
  - k = log_2n

- 각 합병단계의 비교 연산
  - 크기 1인 부분 배열 2개를 합병하는데에는 최대 2번의 비교연산이 필요하고, 부분 배열의 쌍이 4개 이므로 24=8번의 비교 연산이 필요하다.
  - 다음 단계에서는 크기 2인 부분 배열 2개를 합병하는데 최대 4번의 비교 연산이 필요하고, 부분 배열의 쌍이 2개이므로 42=8번의 비교 연산이
    필요하다.
  - 마지막 단계에서는 크기 4인 부분 배열 2개를 합병하는 데는 최대 8번의 비교 연산이 필요하고, 부분 배열의 쌍이 1개이므로 8*1=8번의 비교 연산이
    필요하다.
  - 이것을 일반화하면 하나의 합병 단계에서는 최대 N번의 비교 연산을 수행함을 알 수 있다.
  - 즉, 최대 n 번

- 순환호출의 깊이만큼의 합병 단계 * 각 합병 단계의 비교 연산 = n log_2 n

- 이동 횟수
  - 순환 호출의 깊이 (합병 단계의 수)
    - k = log_2 n
  - 각 합병 단계의 이동 연산
    - 임시 배열에 복사했다가 다시 가져와야 되므로 이동 연산은 총 부분 배열에 들어 있는 요소의 개수가 N인 경우, 레코드의 이동이 2n번 발생한다.
    - 순환호출의 깊이 만큼의 합병 단계 * 각 합병 단계의 이동 연산 = 2nlog_2n
    - T(n) = nlog₂n(비교) + 2nlog₂n(이동) = 3nlog₂n = O(nlog₂n)

>합병 정렬은 일반적인 경우 다음 시간에 배울 퀵 정렬보다 느리지만 어떠한 상황에서도 정확히 O(NlogN)을 보장할 수 있다는 점에서 매우 효율적인 알고리즘이다.

### mergeSort(arr, left, right)
- 재귀적으로 배열을 나누는 함수
- 배열을 더 이상 쪼갤 수 없을때까지 left < right 인 조건으로 재귀 호출

코드 흐름:
1. mid를 기준으로 두 부분으로 나눈다
2. 왼쪽을 재귀적으로 정렬
3. 오른쪽을 재귀적으로 정렬
4. 정렬된 두 부분을 병합

### merge(arr, left, mid, right)
- 나눠진 두 배열을 정렬하며 하나로 병합
- 임시배열 L[], R[]에 값 복사 -> 두 배열을 비교 -> 정렬된 상태로 원래 배열에 다시 채움

코드 흐름
1. 임시 배열에 복사 (L, R)
2. 포인터 i, j를 이용해 두 배열을 순회
3. 작은값을 먼저 삽입
4. 남은 요소가 있다면 뒤이어 삽입

자료구조를 탐색하는 방법은 이진 탐색 말고도 많이 있습니다. 그러니 이진 탐색에만 집착하지 않길 바랍니다. 예를 들어, 어떤 노드를
찾는 탐색 작업에는 이진 트리를 사용할 수도 있고, 해시테이블을 사용할 수도 있습니다. 이진 탐색에만 얽매이지 않도록 합시다.

출처: https://cdragon.tistory.com/entry/Algorithm-Quick-Sort%ED%80%B5-%EC%A0%95%EB%A0%AC, 코딩테스트완벽가이드, https://st-lab.tistory.com/168


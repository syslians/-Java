# 정렬과 탐색

## 정렬 알고리즘의 종류
<img width="1005" height="632" alt="image" src="https://github.com/user-attachments/assets/e8886bc6-0c26-4510-9779-2b60d01b749f" />

### 널리 사용되는 정렬 알고리즘
자주 사용되는 정렬 알고리즘을 알아 두면 문제풀이 능력을 크게 향상시킬 수 있습니다. 아래 정리한 알고리즘 가운데에서는 병합 정렬(merge sort), 
퀵 정렬(quick sort), 버킷 정렬(bucket sort)와 관련된 문제가 가장 많이 출제 되는것으로 보입니다. 

| 알고리즘 종류 | 설명 |
|--------|--------|
| 퀵 정렬 (Quick Sort) | 분할 정복 방식을 이용하여 배열을 빠르게 정렬하는 알고리즘입니다. |
| Arrays.sort()| 퀵 정렬을 사용하여 배열을 정렬하는데 사용되며 기본 타입 배열과 객체 타입 배열 모두에 대해 사용할 수 있습니다. |
| Collections.sort() | 퀵 정렬을 사용하여 객체를 정렬하는데 사용되며 List, Set, Queue 등의 컬렉션 프레임워크에 대해 사용할 수 있습니다. |
| 버블 정렬 (Bubble Sort) | 인접한 두 원소를 비교하여 큰 값을 오른쪽으로 이동시키는 방식으로 정렬하는 알고리즘입니다. |
| 선택 정렬 (Selection Sort) | 주어진 배열에서 최소값을 찾아 맨 앞 원소와 교환하는 방식으로 정렬하는 알고리즘입니다. |
| 삽입 정렬 (Insertion Sort) | 정렬되어 있는 부분집합 내에서 자신이 들어갈 위치를 찾아 삽입하는 방식으로 정렬하는 알고리즘입니다. |
| 병합 정렬 (Merge Sort) | 분할 정복 방식을 이용하여 배열을 정렬하는 알고리즘입니다. |
| 힙 정렬 (Heap Sort) |	힙이라는 자료구조를 이용하여 정렬하는 알고리즘입니다. |
| 기수 정렬 (Radix Sort) | 각 자리의 숫자를 비교하여 정렬하는 알고리즘입니다. |

### 알고리즘 종류별 시간 복잡도와 최악의 시간복잡도
| 알고리즘 종류 | 평균 시간 복잡도 | 최악 시간 복잡도 |
|--------|--------|--------|
| 퀵 정렬(Quick Sort) |	O(nlogn) | O(n^2) |
| 퀵 정렬 : Arrays.sort() |	O(nlogn) | O(n^2) |
| 퀵 정렬 : Collections.sort() |	O(nlogn) |	O(n^2) |
| 버블 정렬 (Bubble Sort) |	O(n^2) |	O(n^2) |
| 선택 정렬 (Selection Sort) | O(n^2) | O(n^2) |
| 삽입 정렬 (Insertion Sort) | O(n^2) |	O(n^2) |
| 합병 정렬 (Merge Sort) | O(nlogn) | O(nlogn) |
| 힙 정렬 (Heap Sort) |	O(nlogn) | O(nlogn) |
| 기수 정렬 (Radix Sort) | O(d(n + k)) | O(d(n + k)) |

### 정렬 시간복잡도 속도 
퀵 정렬(Quick Sort) > 퀵 정렬 : ArraySort() > 퀵 정렬 : Collection.sort() > 버블 정렬(Bubble Sort) 
> 선택 정렬(Selection Sort) > 삽입 정렬(Insertion Sort) > 병합 정렬(Merge Sort) > 힙 정렬(Heap Sort)
> 기수 정렬 (Radix Sort)

### 퀵 정렬 | 실행 시간: 평균 O(n logn), 최악 O(n^2), 메모리 : O(log n)
분할 정복(Divided and Conquer) 방법을 사용하여 구현된 정렬 알고리즘을 의미합니다. 대규모 데이터를 정렬하는데 매우 유용하며, 
많은 프로그래밍 언어에서도 내장된 정렬 함수에 사용하는 알고리즘 입니다.
퀵 정렬은 무작위로 선택한 pivot을 사용하여 배열을 분할하는데, 선정된 pivot보다 작은 원소들은 앞에, 큰 원소들은 뒤로 보냅니다.
배열 분할 작업은 연속된 스왑(swqp) 연산을 통해 효율적으로 수행됩니다. 

배열과 그 부분 배열을 반복적으로 분할해 나가면 결국에 배열은 정렬된 상태에 도달합니다. 하지만, 배열 분할에 사용되는 원소가 
중간값(median), 적어도 중간값에 가까운 값이 되리라는 보장이 없기 때문에, 정렬 알고리즘이 느리게 동작할수도 있습니다.
그래서 최악의 경우에 수행 시간이 O(n^2)이 될 수 있습니다.

### 동작 방식
1. 배열에서 하나의 요소를 기준으로 선택합니다. 이를 Pivot이라 합니다.
2. Pivot을 기준으로 작은 요소는 Pivot의 왼쪽으로, 큰 요소는 Pivot의 오른쪽으로 분할합니다.
3. 분할된 두 개의 하위 배열에 대해 재귀적으로 위의 과정을 반복합니다.
4. 하위 배열이 더 이상 분할되지 않으면 정렬이 완료됩니다.
<img width="1280" height="1839" alt="image" src="https://github.com/user-attachments/assets/a23f1913-a6b6-43a0-83ca-aeca67a6e930" />



```java
void quickSort(int[] arr, int left, int right) {
  int index = partition(arr, left, right);
  if (left < index - 1) { // 왼쪽 분할
    quickSort(arr, left, index - 1);
  }
  if (index < right) { // 오른쪽 절반 정렬
    quickSort(arr, index, right);
  }
}

void swap(int[] arr, int i, int j) {
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}


int partition(int[] arr, int left, int right) {
  int pivot = arr[(left + right) / 2]; // 분할 기준 원소 선정
  while (left <= right) {
    // 왼쪽에서 오른쪽으로 옮겨야 하는 원소 탐색
    while (arr[left] < pivot) left++;

    // 오른쪽에서 왼쪽으로 옮겨야 하는 원소 탐색
    while (arr[right] > pivot) right--;

    // 원소를 스왑한 뒤 left와 right를 이동
    if (left <= right) {
      swap(arr, left, right); // 피벗 기준 좌우값 교환
      Left++;
      right--;
    }
  }

  return left; // 다음 재귀 호출을 위한 새로운 기준점 반환
}
```

```java
import java.util.*;

/*
 * 숫자 배열의 정렬
 */
Integer[] sortNumArr1 = {0, 1, 2, 3, 4};
Integer[] sortNumArr2 = {10, 11, 1, 2, 4};

// [CASE1] 숫자 오름차순 정렬 -1 : 오름차순으로 정렬이 됩니다.
Arrays.sort(sortNumArr1);   // [0, 1, 2, 3, 4]

// [CASE2] 숫자 오름차순 정렬 -2 : 오름차순으로 정렬이 됩니다.
Arrays.sort(sortNumArr1, Comparator.naturalOrder()); // [0, 1, 2, 3, 4]

// [CASE3] 숫자 내림차순 정렬 -1 : 내림차순으로 정렬이 됩니다.(* 해당 주의 사항은 Wrapper Class 를 이용하여야 합니다.)
Arrays.sort(sortNumArr1, Collections.reverseOrder());   // [4, 3, 2, 1, 0]

// [CASE4] 숫자 내림차순 정렬 -2 : 내림차순으로 정렬이 됩니다.(* 해당 주의 사항은 Wrapper Class 를 이용하여야 합니다.)
Arrays.sort(sortNumArr1, Comparator.reverseOrder());   // [4, 3, 2, 1, 0]

/*
 * 문자열의 정렬-1 : 대소문자를 구분하여 정렬하는 방식
 */
String[] sortStrArr1 = {"strawberry", "Strawberry", "mango", "Mango", "cherry", "Cherry", "banana", "Banana", "apple", "Apple"};

// [CASE1] 문자 정렬 : 오름차순으로 정렬합니다.
Arrays.sort(sortStrArr1);                                           // [Apple, Banana, Cherry, Mango, Strawberry, apple, banana, cherry, mango, strawberry]

// [CASE2] 문자 정렬 : 내림차순으로 정렬이 됩니다. (* 해당 주의 사항은 Wrapper Class 를 이용하여야 합니다.)
Arrays.sort(sortStrArr1, Collections.reverseOrder());               // [strawberry, mango, cherry, banana, apple, Strawberry, Mango, Cherry, Banana, Apple]
```

### 기수 정렬(radix sort) | 실행 시간 : O(kn)
기수 정렬은 Queue를 사용해서, 각 자릿수를 기준으로 정렬하는 과정을 반복하는 알고리즘입니다. 기수 정렬 알고리즘은 데이터가
정수(다른 형태의 데이터에 대해서도 마찬가지지만)처럼 유한한 비트로 구성되어 있는 경우에 사용됩니다. 기수 정렬은 각 자릿수를
순회해 나가면서 각 자리의 값에 따라 그룹을 나눕니다. 가령 정수 배열이 주어졌다고 하면 처음에는 첫 번째 자릿수를 기준으로
정렬합니다. 따라서 첫 번째 자릿수가 0인 수들은 같은 그룹에 속합니다. 그런 다음 각 그룹마다 두 번째 자릿수를 기준으로 다시
정렬을 수행합니다. 이 작업을 배열 전체가 정렬될때까지 모든 자릿수에 대해 반복합니다. 비교 연산을 사용하는 정렬 알고리즘은 평균
적으로 O(n logn)보다 나은 성능을 보일 수 없으나, 기수 정렬의 수행 시간은 O(kn)이 됩니다. 여기서 n은 정렬 대상 원소의
갯수이고, k는 자릿수의 갯수입니다. 

### 작동 방식
1. 정렬할 요소들을 가장 낮은 자릿수부터 가장 높은 자릿수까지 반복적으로 정렬합니다.
2. 각 자릿수에 대해 요소들을 해당 자릿수의 값에 따라 그룹화합니다.
3. 그룹화된 요소들을 순서대로 다시 배열합니다.
4. 위의 과정을 가장 높은 자릿수까지 반복하여 정렬이 완료될때까지 진행합니다.
<img width="654" height="320" alt="image" src="https://github.com/user-attachments/assets/24da4281-d297-49bb-927e-d76d64d2c506" />
https://www.ritambhara.in/radix-sort/

### 탐색 알고리즘
탐색 알고리즘 하면 일반적으로 이진 탐색(binary search)가 떠오릅니다. 실제로 이진 탐색은 공부하기 굉장히 좋은 알고리즘입니다.
이진 탐색은 정렬된 배열에서 원소 x를 찾고자 할 때 사용합니다. x를 중간에 위치한 원소와 비교한 뒤 x가 중간에 위치한 값보다 
작다면 배열의 왼쪽 절반을 재탐색하고, 크다면 배열의 오른쪽 절반을 재탐색 합니다. 이 과정을 x를 찾거나 부분 배열의 크기가 0이 
될때까지 반복합니다. 개념 자체는 꽤 간단하지만 세부적인 부분까지 자세히 따지다 보면 생각보다 구현이 어려울 수 있습니다.
아래 코드를 보면서 +1과 -1이 어떻게 사용되었는지 눈여겨보길 바랍니다.

```java
int binarySearch(int[] a, int x) {
  int low = 0;
  int high = a.length - 1;
  int mid;
  while (low <= high) {
    mid = (low + high) / 2;
    if (a[mid] < x) {
      low = mid + 1;
    } else if (a[mid] > x) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return - 1; // 에러
}

int binarySearchRecursive(int[] a, int x, int low, int high) {
  if (low > high) return - 1; // 에러

  int mid = (low + high) / 2;
  if (a[mid] < x) {
    return binarySearchRecursive(a, x, mid + 1, high);
  } else if (a[mid] > x) {
    return binarySearchRecursive(a, x, low, mid - 1);
  } else {
    return mid;
  }
}
```

자료구조를 탐색하는 방법은 이진 탐색 말고도 많이 있습니다. 그러니 이진 탐색에만 집착하지 않길 바랍니다. 예를 들어, 어떤 노드를
찾는 탐색 작업에는 이진 트리를 사용할 수도 있고, 해시테이블을 사용할 수도 있습니다. 이진 탐색에만 얽매이지 않도록 합시다.



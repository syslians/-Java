# 트리(Tree)란?
계층적 구조를 표현하는 자료구조입니다.
부모 -> 자식 노드 형태로 연결되어 있습니다.

일반적으로 1개의 루트노드에서 시작하여
각 노드는 여러 자식 노드를 가질 수 있습니다.

## 용어 정리
![Pasted image 20250713124548.png](Pasted%20image%2020250713124548.png)

| 용어           | 설명                      |
| ------------ | ----------------------- |
| 루트 노드 (Root) | 트리의 가장 위 노드, 시작점        |
| 리프 노드 (Leaf) | 자식이 없는 가장 끝에 위치한 노드, 끝점 |
| 부모/자식 노드     | 트리에서 연결된 위, 아래 관계       |
| 서브트리         | 어떤 노드를 루트 임의 지정하여 있는 트리 |
| 깊이           | 루트에서 노드까지의 거리           |
| 높이           | 트리 전체에서 가장 높은 노드까지의 거리  |

## 시간 복잡도
| 연산  | 평균       | 최악 (불균형 트리) |
| --- | -------- | ----------- |
| 삽입  | O(log N) | O(N)        |
| 삭제  | O(log N) | O(N)        |
| 탐색  | O(log N) | O(N)        |
이진 탐색 트리는 좌측에는 작은 값, 우측에는 큰 값을 저장하는 방식입니다.
중간부터 반씩 줄여가며 탐색이 가능하기에 O(log N)입니다.

하지만 한 쪽으로 치우쳐진 트리의 경우 선형 구조를 띄고 있어서 O(N)이 나오게 됩니다.

# 순회 방식
순회란, 모든 노드를 방문하는 것을 의미합니다.
루트 노드 기준으로 순회 방식을 세가지로 나눌 수 있습니다.

| 순회 방식 | 방문 순서           |
| ----- | --------------- |
| 전위    | 루트 -> 왼쪽 -> 오른쪽 |
| 중위    | 왼쪽 -> 루트 -> 오른쪽 |
| 후위    | 왼쪽 -> 오른쪽 -> 루트 |

## 자식 노드 계산 법
![Pasted image 20250713125532.png](Pasted%20image%2020250713125532.png)
완전 이진 트리일 때
트리를 배열로 표현하면 자식 노드의 인덱스를 수식으로 계산할 수 있습니다.

- 왼쪽 : 루트 노드 인덱스 * 2
- 오른쪽 : 루트 노드 인덱스 * 2 + 1

반대로 부모 노드를 구할 수도 있습니다.
- 부모 노드 : 자식 인덱스 / 2

| 인덱스 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 값   | -   | 30  | 17  | 48  | 5   | 23  | 37  | 50  |

위의 이미지를 기준으로,
30의 왼쪽 자식 노드 인덱스 : 1 * 2 = 2
30의 오른쪽 자식 노드 인덱스 : 1 * 2 + 1 = 3
23의 부모 인덱스 : 5 / 2 = 2

### 만약 인덱스를 0부터 활용한다고 했을 때
만약 배열 인덱스를 0부터 쓴다고 하면 아래와 같은 공식을 적용할 수 있습니다.
- 왼쪽 : 루트 노드 인덱스 * 2 + 1
- 오른쪽 : 루트 노드 인덱스 * 2 + 2
- 부모 노드 : (자식 노드 인덱스 - 1) / 2

| 인덱스 | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 값   | 30  | 17  | 48  | 5   | 23  | 37  | 50  |
30의 왼쪽 자식 노드 인덱스 : 0 * 2 + 1 = 1
30의 오른쪽 자식 노드 인덱스 : 0 * 2 + 2 = 2

50의 부모 노드 인덱스 : (6 - 1) / 2 = 2

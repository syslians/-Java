# 해시란?
어떤 데이터를 빠르게 찾기 위하여, `해시 함수`를 통해 값을 위치로 매핑시켜주는 기법입니다.

![Pasted image 20250713095908.png](Pasted%20image%2020250713095908.png)

예를 들어, "자바"라는 단어를 저장할 때,
이걸 "1번 위치"에 저장하고 나중에 "자바"를 다시 찾을 때 역시 "1번 위치"를 꺼내는 방식입니다.

![Pasted image 20250713100039.png](Pasted%20image%2020250713100039.png)

값을 위치로 바꿔주는 역할은 **해시 함수**를 통해 처리가 되며,
값을 저장하는 자료구조는 **해시 테이블**입니다.

# 시간 복잡도
평균적으로 삽입, 삭제, 탐색 모두 O(1)입니다.
해시 충돌이 발생하게 될 경우에는 O(N)까지 느려질 수 있지만, 대부분은 빠른것이 특징입니다.

HashMap, HashSet은 내부적으로 버킷(배열, 연결리스트) 구조를 사용합니다.
데이터를 저장할 위치를 해시 함수로 계산하여 해당 위치에 바로 저장하거나 꺼내게 됩니다.
이 때, **배열 인덱스로 접근**하기 때문에, 삽입, 삭제, 탐색 모두 평균적으로 O(1) 시간에 가능합니다.
```java
map.put("JAVA", 1); // O(1)
map.get("JAVA");    // O(1)
map.remove("JAVA"); // O(1)
```

# 주요 해시 자료구조
주로 `HashMap<K, V>`또는 `HashSet<E>`를 사용하게 됩니다.

| 자료구조                  | 설명                         |
| --------------------- | -------------------------- |
| `HashMap<K, V>`       | key-value 형식, 빠른 검색 (O(1)) |
| `HashSet<E>`          | 중복 없는 값 저장                 |
|                       |                            |
| `LinkedHashMap<K, V>` | `HashMap`에 입력 순서 적용        |
| `TreeMap<K, V>`       | 정렬시 사용                     |
- HashSet의 경우, 내부적으로 `HashMap`을 사용하고 있습니다.
```java
public class HashSet<E>  
    extends AbstractSet<E>  
    implements Set<E>, Cloneable, java.io.Serializable  
{  
	...
    private transient HashMap<E,Object> map; // ✅ 해시맵을 사용하고 있다.
```

# 해시 자료구조의 특징
- 빠른 검색 속도
    - 평균적으로 Key 기준 조회가 O(1), 해시 충돌의 경우 O(N)
- 중복 허용 여부
    - HashMap은 key의 중복 허용 ❌
    - HashSet은 전체 중복 허용 ❌ -> 중복 제거하여 처리하는 문제에 적합
- 순서 보장 여부
    - HashMap, HashSet은 순서를 보장하지 않음
    - LinkedHashMap, LinkedHashSet을 이용
- null 허용
    - 자바의 HashTable은 null을 허용하지 않음
    - HashMap은 key의 null 1개 허용, value에는 여러개 가능
- equals(), hashCode() 재정의
    - 반드시 재정의가 필요합니다.

> [!NOTE]- 🚨 만약 `equals()`와 `hashCode()`를 재정의하지 않는다면?
>
> `equals()`의 역할은 객체가 서로 동일한지 **동등성**을 판단하는 메서드 입니다.
>  객체의 타입과 값이 동일 하더라도, 주소값이 다르게 되면 다른 값으로 판단할 수 있습니다.
>
>  이를 방지하고자 동일 객체, 동일 값일 때에는 동일한 해시 값이 나올 수 있도록 `equals()`와 `hashCode()` 재정의가 필요합니다.

# 해시 충돌이란?
서로 다른 두 개의 Key가 같은 해시 값을 가질 때를 **해시 충돌**이라고 합니다.

```
"JAVA" → hashCode: 42
"C++"  → hashCode: 42  ← 💥 충돌!
```
이런 경우 같은 위치(버킷)에 여러 개의 값을 넣게 됩니다.
배열 한 칸에 여러 요소를 **리스트**로 저장하게 되는데,
하나의 버킷 안에서 선형 검색(O(N))이 발생할 수 있게 됩니다.

이는 **체이닝** 방식이라고 합니다.

## 해시 충돌 처리 방식
### 체이닝
![Pasted image 20250713102301.png](Pasted%20image%2020250713102301.png)
위에서 설명한 방식입니다.

같은 버킷에 충돌된 값을 LinkedList로 연결하여 저장하는 방식입니다.
자바에서 HashMap은 해당 방식을 통해 해시 충돌을 처리하고 있습니다.

Java 8 이후부터는 동일 버킷에 저장된 엔트리가 8개 이상이게 되면, LinkedList에서 Red Black Tree로 바꾸어 성능을 개선하게 됩니다.

![Pasted image 20250713102701.png](Pasted%20image%2020250713102701.png)

이 때에는 O(log N)으로 성능이 향상되게 됩니다.

## 오픈 어드레싱
충돌 발생 시, 다른 빈 버킷을 찾아 데이터를 넣는 방식입니다.
데이터를 찾을 때에도 데이터 넣는 방식처럼 이동하며 탐색하게 됩니다.

### 선형 탐사
해시 충돌이 되면 일정 간격 (보통 1) 다음 버킷에 데이터를 저장하게 됩니다.
단, 일정 버킷 중심으로 뭉치는 클러스터링 현상을 조심해야 합니다.

### 제곱 탐사
충돌 시 제곱근 다음 버킷에 데이터를 저장하게 됩니다.

### 더블 해싱
해시 함수를 하나 더 사용하는 것을 의미합니다.

## 재해싱
해시 테이블의 크기를 늘리고, 다시 데이터를 재배칭하는 방식입니다.

----

# 자주 등장하는 패턴
## 1. 빈도수 세기 (카운팅)
- 가장 많이 등장한 문자열 찾기
- 숫자 등장 횟수 세기
- `Map<String, Integer>` 자료구조로 해결

## 2. 두 개의 배열 비교
- 하나의 배열을 해시맵에 저장해두고, 다른 배열을 탐색하는 방식

## 3. 중복 여부 체크
- Set을 사용하여 중복 여부를 쉽게 판단
- 서로 다른 값 개수, 중복 제거

## 4. 누락된 값, 존재하지 않는 값 찾기
- 특정 조건을 만족하지 않는 값을 찾을 때, 해시 사용

---

# 주의할 점
## 충돌 (Collision)
HashMap Key로는 `equals()`와 `hashCode()`가 정의된 객체에만 사용해야 합니다.

## 미정렬
`HashMap`, `HashSet`은 순서 보장을하지 않습니다.
순서가 중요하다면, `LinkedHashMap`, `TreeMap` 사용을 고려해볼 수 있습니다.

## 초기화 편하게 하기
`getOrDefault`를 통해 기본 값 설정을 유용하게 할 수 있습니다.
이를 이용해 NPE를 방지할 수 있습니다.
```java
Map<String, Integer> map = new HashMap<>();
map.put("a", map.getOrDefault("a", 0) + 1);
```

## 동일 key로 put()하면 덮어쓰기 됨
```java
map.put("A", 1);
map.put("A", 2); // 1은 사라지고 2로 덮어씀
```

## 반복 중 Map 수정 시, ConcurrentModificationException
```java
for (String key : map.keySet()) {
map.remove(key); // ❌ 예외 발생
}
```
![Pasted image 20250713103606.png](Pasted%20image%2020250713103606.png)

## 로드 팩터와 초기 용량 고려
많은 데이터를 다룰 경우, 초기 용량을 설정하면 리사이징 비용을 줄일 수 있게 됩니다.
```java
Map<String, String> map = new HashMap<>(1024); // 예상 크기
```
